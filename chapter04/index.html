<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-D5P830S5Z3"></script>
    <script data-cfasync="false">window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());gtag('config', 'G-D5P830S5Z3');</script>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="turbo-root" content="/book-network-programming-csharp">
    <meta name="turbo-cache-control" content="no-cache" data-turbo-track="reload" data-track-token="3.5.0.764766980098">

    <!-- See retype.com -->
    <meta name="generator" content="Retype 3.5.0">

    <!-- Primary Meta Tags -->
    <title>Asynchronous Programming with Async/Await</title>
    <meta name="title" content="Asynchronous Programming with Async/Await">
    <meta name="description" content="Welcome to a crucial chapter in your journey through Network Programming using C#, where we delve into Asynchronous programming using ">

    <!-- Canonical -->
    <link rel="canonical" href="https://cwoodruff.github.io/book-network-programming-csharp/chapter04/">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://cwoodruff.github.io/book-network-programming-csharp/chapter04/">
    <meta property="og:title" content="Asynchronous Programming with Async/Await">
    <meta property="og:description" content="Welcome to a crucial chapter in your journey through Network Programming using C#, where we delve into Asynchronous programming using ">

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://cwoodruff.github.io/book-network-programming-csharp/chapter04/">
    <meta property="twitter:title" content="Asynchronous Programming with Async/Await">
    <meta property="twitter:description" content="Welcome to a crucial chapter in your journey through Network Programming using C#, where we delve into Asynchronous programming using ">

    <script data-cfasync="false">(function () { var el = document.documentElement, m = localStorage.getItem("doc_theme"), wm = window.matchMedia; if (m === "dark" || (!m && wm && wm("(prefers-color-scheme: dark)").matches)) { el.classList.add("dark") } else { el.classList.remove("dark") } })();</script>

    <link href="../images/favicon.png" rel="icon">
    <link href="../resources/css/retype.css?v=3.5.0.764766980098" rel="stylesheet">

    <script data-cfasync="false" src="../resources/js/config.js?v=3.5.0.764766980098" data-turbo-eval="false" defer></script>
    <script data-cfasync="false" src="../resources/js/retype.js?v=3.5.0" data-turbo-eval="false" defer></script>
    <script id="lunr-js" data-cfasync="false" src="../resources/js/lunr.js?v=3.5.0.764766980098" data-turbo-eval="false" defer></script>
    <script id="prism-js" data-cfasync="false" src="../resources/js/prism.js?v=3.5.0.764766980098" defer></script>
</head>
<body>
    <div id="docs-app" class="relative text-base antialiased text-gray-700 bg-white font-body dark:bg-dark-850 dark:text-dark-300">
        <div class="absolute bottom-0 left-0 bg-gray-100 dark:bg-dark-800" style="top: 5rem; right: 50%"></div>
    
        <header id="docs-site-header" class="sticky top-0 z-30 flex w-full h-16 bg-white border-b border-gray-200 md:h-20 dark:bg-dark-850 dark:border-dark-650">
            <div class="container relative flex items-center justify-between pr-6 grow md:justify-start">
                <!-- Mobile menu button skeleton -->
                <button v-cloak class="skeleton docs-mobile-menu-button flex items-center justify-center shrink-0 overflow-hidden dark:text-white focus:outline-none rounded-full w-10 h-10 ml-3.5 md:hidden"><svg xmlns="http://www.w3.org/2000/svg" class="mb-px shrink-0" width="24" height="24" viewBox="0 0 24 24" role="presentation" style="margin-bottom: 0px;"><g fill="currentColor"><path d="M2 4h20v2H2zM2 11h20v2H2zM2 18h20v2H2z"></path></g></svg></button>
                <div v-cloak id="docs-sidebar-toggle"></div>
        
                <!-- Logo -->
                <div class="flex items-center justify-between h-full py-2 md:w-75">
                    <div class="flex items-center px-2 md:px-6">
                        <a id="docs-site-logo" href="../" class="flex items-center leading-snug text-xl">
                            <span class="w-10 mr-2 grow-0 shrink-0 overflow-hidden">
                                <img class="max-h-10 dark:hidden md:inline-block" src="../images/network200.png">
                                <img class="max-h-10 hidden dark:inline-block" src="../images/network200.png">
                            </span>
                            <span class="dark:text-white font-semibold line-clamp-1 md:line-clamp-2">Networking Programming with C/# 12 and /.NET 8</span>
                        </a><span class="hidden px-2 py-1 ml-4 text-sm font-semibold leading-none text-root-logo-label-text bg-root-logo-label-bg rounded-sm md:inline-block">v1</span>
                    </div>
        
                    <span class="hidden h-8 border-r md:inline-block dark:border-dark-650"></span>
                </div>
        
                <div class="flex justify-between md:grow">
                    <!-- Top Nav -->
                    <nav class="hidden md:flex">
                        <ul class="flex flex-col mb-4 md:pl-16 md:mb-0 md:flex-row md:items-center">
                            <li class="mr-6">
                                <a class="py-2 md:mb-0 inline-flex items-center text-sm whitespace-nowrap transition-colors duration-200 ease-linear md:text-blue-500 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-200" href="../">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="mb-px mr-1" width="18" height="18" viewBox="0 0 24 24" role="presentation">
                                        <g fill="currentColor">
                                            <path d="M11.03 2.59a1.501 1.501 0 0 1 1.94 0l7.5 6.363a1.5 1.5 0 0 1 .53 1.144V19.5a1.5 1.5 0 0 1-1.5 1.5h-5.75a.75.75 0 0 1-.75-.75V14h-2v6.25a.75.75 0 0 1-.75.75H4.5A1.5 1.5 0 0 1 3 19.5v-9.403c0-.44.194-.859.53-1.144ZM12 3.734l-7.5 6.363V19.5h5v-6.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v6.25h5v-9.403Z"/>
                                        </g>
                                    </svg>
                                    <span>Home</span>
                                </a>
                            </li>
                            <li class="mr-6">
                                <a class="py-2 md:mb-0 inline-flex items-center text-sm whitespace-nowrap transition-colors duration-200 ease-linear md:text-blue-500 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-200" href="https://github.com/cwoodruff/book-network-programming-csharp/issues" target="_blank">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="mb-px mr-1" width="18" height="18" viewBox="0 0 24 24" role="presentation">
                                        <g fill="currentColor">
                                            <path d="M1.75 1h12.5c.966 0 1.75.784 1.75 1.75v9.5A1.75 1.75 0 0 1 14.25 14H8.061l-2.574 2.573A1.458 1.458 0 0 1 3 15.543V14H1.75A1.75 1.75 0 0 1 0 12.25v-9.5C0 1.784.784 1 1.75 1ZM1.5 2.75v9.5c0 .138.112.25.25.25h2a.75.75 0 0 1 .75.75v2.19l2.72-2.72a.749.749 0 0 1 .53-.22h6.5a.25.25 0 0 0 .25-.25v-9.5a.25.25 0 0 0-.25-.25H1.75a.25.25 0 0 0-.25.25Z"/><path d="M22.5 8.75a.25.25 0 0 0-.25-.25h-3.5a.75.75 0 0 1 0-1.5h3.5c.966 0 1.75.784 1.75 1.75v9.5A1.75 1.75 0 0 1 22.25 20H21v1.543a1.457 1.457 0 0 1-2.487 1.03L15.939 20H10.75A1.75 1.75 0 0 1 9 18.25v-1.465a.75.75 0 0 1 1.5 0v1.465c0 .138.112.25.25.25h5.5a.75.75 0 0 1 .53.22l2.72 2.72v-2.19a.75.75 0 0 1 .75-.75h2a.25.25 0 0 0 .25-.25v-9.5Z"/>
                                        </g>
                                    </svg>
                                    <span>Issues</span>
                                </a>
                            </li>
                            <li class="mr-6">
                                <a class="py-2 md:mb-0 inline-flex items-center text-sm whitespace-nowrap transition-colors duration-200 ease-linear md:text-blue-500 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-200" href="https://twitter.com/cwoodruff/" target="_blank">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="mb-px mr-1" width="18" height="18" viewBox="0 0 24 24" role="presentation">
                                        <g fill="currentColor">
                                            <path d="M19 0h-14c-2.761 0-5 2.239-5 5v14c0 2.761 2.239 5 5 5h14c2.762 0 5-2.239 5-5v-14c0-2.761-2.238-5-5-5zm-.139 9.237c.209 4.617-3.234 9.765-9.33 9.765-1.854 0-3.579-.543-5.032-1.475 1.742.205 3.48-.278 4.86-1.359-1.437-.027-2.649-.976-3.066-2.28.515.098 1.021.069 1.482-.056-1.579-.317-2.668-1.739-2.633-3.26.442.246.949.394 1.486.411-1.461-.977-1.875-2.907-1.016-4.383 1.619 1.986 4.038 3.293 6.766 3.43-.479-2.053 1.08-4.03 3.199-4.03.943 0 1.797.398 2.395 1.037.748-.147 1.451-.42 2.086-.796-.246.767-.766 1.41-1.443 1.816.664-.08 1.297-.256 1.885-.517-.439.656-.996 1.234-1.639 1.697z"/>
                                        </g>
                                    </svg>
                                    <span>Twitter</span>
                                </a>
                            </li>
        
                        </ul>
                    </nav>
        
                    <!-- Header Right Skeleton -->
                    <div v-cloak class="flex justify-end grow skeleton">
        
                        <!-- Search input mock -->
                        <div class="relative hidden w-40 lg:block lg:max-w-sm lg:ml-auto">
                            <div class="absolute flex items-center justify-center h-full pl-3 dark:text-dark-300">
                                <svg xmlns="http://www.w3.org/2000/svg" class="icon-base" width="16" height="16" viewBox="0 0 24 24" aria-labelledby="icon" role="presentation" style="margin-bottom: 1px;"><g fill="currentColor" ><path d="M21.71 20.29l-3.68-3.68A8.963 8.963 0 0020 11c0-4.96-4.04-9-9-9s-9 4.04-9 9 4.04 9 9 9c2.12 0 4.07-.74 5.61-1.97l3.68 3.68c.2.19.45.29.71.29s.51-.1.71-.29c.39-.39.39-1.03 0-1.42zM4 11c0-3.86 3.14-7 7-7s7 3.14 7 7c0 1.92-.78 3.66-2.04 4.93-.01.01-.02.01-.02.01-.01.01-.01.01-.01.02A6.98 6.98 0 0111 18c-3.86 0-7-3.14-7-7z" ></path></g></svg>
                            </div>
                            <input class="w-full h-10 placeholder-gray-400 transition-colors duration-200 ease-in bg-gray-200 border border-transparent rounded md:text-sm hover:bg-white hover:border-gray-300 focus:outline-none focus:bg-white focus:border-gray-500 dark:bg-dark-600 dark:border-dark-600 dark:placeholder-dark-400" style="padding: 0.625rem 0.75rem 0.625rem 2rem" type="text" placeholder="Search">
                        </div>
        
                        <!-- Mobile search button -->
                        <div class="flex items-center justify-center w-10 h-10 lg:hidden">
                            <svg xmlns="http://www.w3.org/2000/svg" class="shrink-0 icon-base" width="20" height="20" viewBox="0 0 24 24" aria-labelledby="icon" role="presentation" style="margin-bottom: 0px;"><g fill="currentColor" ><path d="M21.71 20.29l-3.68-3.68A8.963 8.963 0 0020 11c0-4.96-4.04-9-9-9s-9 4.04-9 9 4.04 9 9 9c2.12 0 4.07-.74 5.61-1.97l3.68 3.68c.2.19.45.29.71.29s.51-.1.71-.29c.39-.39.39-1.03 0-1.42zM4 11c0-3.86 3.14-7 7-7s7 3.14 7 7c0 1.92-.78 3.66-2.04 4.93-.01.01-.02.01-.02.01-.01.01-.01.01-.01.02A6.98 6.98 0 0111 18c-3.86 0-7-3.14-7-7z" ></path></g></svg>
                        </div>
        
                        <!-- Dark mode switch placeholder -->
                        <div class="w-10 h-10 lg:ml-2"></div>
        
                        <!-- History button -->
                        <div class="flex items-center justify-center w-10 h-10" style="margin-right: -0.625rem;">
                            <svg xmlns="http://www.w3.org/2000/svg" class="shrink-0 icon-base" width="22" height="22" viewBox="0 0 24 24" aria-labelledby="icon" role="presentation" style="margin-bottom: 0px;"><g fill="currentColor" ><g ><path d="M12.01 6.01c-.55 0-1 .45-1 1V12a1 1 0 00.4.8l3 2.22a.985.985 0 001.39-.2.996.996 0 00-.21-1.4l-2.6-1.92V7.01c.02-.55-.43-1-.98-1z"></path><path d="M12.01 1.91c-5.33 0-9.69 4.16-10.05 9.4l-.29-.26a.997.997 0 10-1.34 1.48l1.97 1.79c.19.17.43.26.67.26s.48-.09.67-.26l1.97-1.79a.997.997 0 10-1.34-1.48l-.31.28c.34-4.14 3.82-7.41 8.05-7.41 4.46 0 8.08 3.63 8.08 8.09s-3.63 8.08-8.08 8.08c-2.18 0-4.22-.85-5.75-2.4a.996.996 0 10-1.42 1.4 10.02 10.02 0 007.17 2.99c5.56 0 10.08-4.52 10.08-10.08.01-5.56-4.52-10.09-10.08-10.09z"></path></g></g></svg>
                        </div>
                    </div>
        
                    <div v-cloak class="flex justify-end grow">
                        <div id="docs-mobile-search-button"></div>
                        <doc-search-desktop></doc-search-desktop>
        
                        <doc-theme-switch class="lg:ml-2"></doc-theme-switch>
                        <doc-history></doc-history>
                    </div>
                </div>
            </div>
        </header>
    
        <div class="container relative flex bg-white">
            <!-- Sidebar Skeleton -->
            <div v-cloak class="fixed flex flex-col shrink-0 duration-300 ease-in-out bg-gray-100 border-gray-200 sidebar top-20 w-75 border-r h-screen md:sticky transition-transform skeleton dark:bg-dark-800 dark:border-dark-650">
            
                <!-- Render this div, if config.showSidebarFilter is `true` -->
                <div class="flex items-center h-16 px-6">
                    <input class="w-full h-8 px-3 py-2 transition-colors duration-200 ease-linear bg-white border border-gray-200 rounded shadow-none text-sm focus:outline-none focus:border-gray-600 dark:bg-dark-600 dark:border-dark-600" type="text" placeholder="Filter">
                </div>
            
                <div class="pl-6 mt-1 mb-4">
                    <div class="w-32 h-3 mb-4 bg-gray-200 rounded-full loading dark:bg-dark-600"></div>
                    <div class="w-48 h-3 mb-4 bg-gray-200 rounded-full loading dark:bg-dark-600"></div>
                    <div class="w-40 h-3 mb-4 bg-gray-200 rounded-full loading dark:bg-dark-600"></div>
                    <div class="w-32 h-3 mb-4 bg-gray-200 rounded-full loading dark:bg-dark-600"></div>
                    <div class="w-48 h-3 mb-4 bg-gray-200 rounded-full loading dark:bg-dark-600"></div>
                    <div class="w-40 h-3 mb-4 bg-gray-200 rounded-full loading dark:bg-dark-600"></div>
                </div>
            
                <div class="shrink-0 mt-auto bg-transparent dark:border-dark-650">
                    <a class="flex items-center justify-center flex-nowrap h-16 text-gray-400 dark:text-dark-400 hover:text-gray-700 dark:hover:text-dark-300 transition-colors duration-150 ease-in docs-powered-by" target="_blank" href="https://retype.com/" rel="noopener">
                        <span class="text-xs whitespace-nowrap">Powered by</span>
                        <svg xmlns="http://www.w3.org/2000/svg" class="ml-2" fill="currentColor" width="96" height="20" overflow="visible"><path d="M0 0v20h13.59V0H0zm11.15 17.54H2.44V2.46h8.71v15.08zM15.8 20h2.44V4.67L15.8 2.22zM20.45 6.89V20h2.44V9.34z"/><g><path d="M40.16 8.44c0 1.49-.59 2.45-1.75 2.88l2.34 3.32h-2.53l-2.04-2.96h-1.43v2.96h-2.06V5.36h3.5c1.43 0 2.46.24 3.07.73s.9 1.27.9 2.35zm-2.48 1.1c.26-.23.38-.59.38-1.09 0-.5-.13-.84-.4-1.03s-.73-.28-1.39-.28h-1.54v2.75h1.5c.72 0 1.2-.12 1.45-.35zM51.56 5.36V7.2h-4.59v1.91h4.13v1.76h-4.13v1.92h4.74v1.83h-6.79V5.36h6.64zM60.09 7.15v7.48h-2.06V7.15h-2.61V5.36h7.28v1.79h-2.61zM70.81 14.64h-2.06v-3.66l-3.19-5.61h2.23l1.99 3.45 1.99-3.45H74l-3.19 5.61v3.66zM83.99 6.19c.65.55.97 1.4.97 2.55s-.33 1.98-1 2.51-1.68.8-3.04.8h-1.23v2.59h-2.06V5.36h3.26c1.42 0 2.45.28 3.1.83zm-1.51 3.65c.25-.28.37-.69.37-1.22s-.16-.92-.48-1.14c-.32-.23-.82-.34-1.5-.34H79.7v3.12h1.38c.68 0 1.15-.14 1.4-.42zM95.85 5.36V7.2h-4.59v1.91h4.13v1.76h-4.13v1.92H96v1.83h-6.79V5.36h6.64z"/></g></svg>
                    </a>
                </div>
            </div>
            
            <!-- Sidebar component -->
            <doc-sidebar v-cloak>
                <template #sidebar-footer>
                    <div class="shrink-0 mt-auto border-t md:bg-transparent md:border-none dark:border-dark-650">
            
                        <div class="py-3 px-6 md:hidden border-b dark:border-dark-650">
                            <nav>
                                <ul class="flex flex-wrap justify-center items-center">
                                    <li class="mr-6">
                                        <a class="block py-1 inline-flex items-center text-sm whitespace-nowrap transition-colors duration-200 ease-linear md:text-blue-500 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-200" href="../">
                                            <svg xmlns="http://www.w3.org/2000/svg" class="mb-px mr-1" width="18" height="18" viewBox="0 0 24 24" role="presentation">
                                                <g fill="currentColor">
                                                    <path d="M11.03 2.59a1.501 1.501 0 0 1 1.94 0l7.5 6.363a1.5 1.5 0 0 1 .53 1.144V19.5a1.5 1.5 0 0 1-1.5 1.5h-5.75a.75.75 0 0 1-.75-.75V14h-2v6.25a.75.75 0 0 1-.75.75H4.5A1.5 1.5 0 0 1 3 19.5v-9.403c0-.44.194-.859.53-1.144ZM12 3.734l-7.5 6.363V19.5h5v-6.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v6.25h5v-9.403Z"/>
                                                </g>
                                            </svg>
                                            <span>Home</span>
                                        </a>
                                    </li>
                                    <li class="mr-6">
                                        <a class="block py-1 inline-flex items-center text-sm whitespace-nowrap transition-colors duration-200 ease-linear md:text-blue-500 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-200" href="https://github.com/cwoodruff/book-network-programming-csharp/issues" target="_blank">
                                            <svg xmlns="http://www.w3.org/2000/svg" class="mb-px mr-1" width="18" height="18" viewBox="0 0 24 24" role="presentation">
                                                <g fill="currentColor">
                                                    <path d="M1.75 1h12.5c.966 0 1.75.784 1.75 1.75v9.5A1.75 1.75 0 0 1 14.25 14H8.061l-2.574 2.573A1.458 1.458 0 0 1 3 15.543V14H1.75A1.75 1.75 0 0 1 0 12.25v-9.5C0 1.784.784 1 1.75 1ZM1.5 2.75v9.5c0 .138.112.25.25.25h2a.75.75 0 0 1 .75.75v2.19l2.72-2.72a.749.749 0 0 1 .53-.22h6.5a.25.25 0 0 0 .25-.25v-9.5a.25.25 0 0 0-.25-.25H1.75a.25.25 0 0 0-.25.25Z"/><path d="M22.5 8.75a.25.25 0 0 0-.25-.25h-3.5a.75.75 0 0 1 0-1.5h3.5c.966 0 1.75.784 1.75 1.75v9.5A1.75 1.75 0 0 1 22.25 20H21v1.543a1.457 1.457 0 0 1-2.487 1.03L15.939 20H10.75A1.75 1.75 0 0 1 9 18.25v-1.465a.75.75 0 0 1 1.5 0v1.465c0 .138.112.25.25.25h5.5a.75.75 0 0 1 .53.22l2.72 2.72v-2.19a.75.75 0 0 1 .75-.75h2a.25.25 0 0 0 .25-.25v-9.5Z"/>
                                                </g>
                                            </svg>
                                            <span>Issues</span>
                                        </a>
                                    </li>
                                    <li class="mr-6">
                                        <a class="block py-1 inline-flex items-center text-sm whitespace-nowrap transition-colors duration-200 ease-linear md:text-blue-500 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-200" href="https://twitter.com/cwoodruff/" target="_blank">
                                            <svg xmlns="http://www.w3.org/2000/svg" class="mb-px mr-1" width="18" height="18" viewBox="0 0 24 24" role="presentation">
                                                <g fill="currentColor">
                                                    <path d="M19 0h-14c-2.761 0-5 2.239-5 5v14c0 2.761 2.239 5 5 5h14c2.762 0 5-2.239 5-5v-14c0-2.761-2.238-5-5-5zm-.139 9.237c.209 4.617-3.234 9.765-9.33 9.765-1.854 0-3.579-.543-5.032-1.475 1.742.205 3.48-.278 4.86-1.359-1.437-.027-2.649-.976-3.066-2.28.515.098 1.021.069 1.482-.056-1.579-.317-2.668-1.739-2.633-3.26.442.246.949.394 1.486.411-1.461-.977-1.875-2.907-1.016-4.383 1.619 1.986 4.038 3.293 6.766 3.43-.479-2.053 1.08-4.03 3.199-4.03.943 0 1.797.398 2.395 1.037.748-.147 1.451-.42 2.086-.796-.246.767-.766 1.41-1.443 1.816.664-.08 1.297-.256 1.885-.517-.439.656-.996 1.234-1.639 1.697z"/>
                                                </g>
                                            </svg>
                                            <span>Twitter</span>
                                        </a>
                                    </li>
            
                                </ul>
                            </nav>
                        </div>
            
                        <a class="flex items-center justify-center flex-nowrap h-16 text-gray-400 dark:text-dark-400 hover:text-gray-700 dark:hover:text-dark-300 transition-colors duration-150 ease-in docs-powered-by" target="_blank" href="https://retype.com/" rel="noopener">
                            <span class="text-xs whitespace-nowrap">Powered by</span>
                            <svg xmlns="http://www.w3.org/2000/svg" class="ml-2" fill="currentColor" width="96" height="20" overflow="visible"><path d="M0 0v20h13.59V0H0zm11.15 17.54H2.44V2.46h8.71v15.08zM15.8 20h2.44V4.67L15.8 2.22zM20.45 6.89V20h2.44V9.34z"/><g><path d="M40.16 8.44c0 1.49-.59 2.45-1.75 2.88l2.34 3.32h-2.53l-2.04-2.96h-1.43v2.96h-2.06V5.36h3.5c1.43 0 2.46.24 3.07.73s.9 1.27.9 2.35zm-2.48 1.1c.26-.23.38-.59.38-1.09 0-.5-.13-.84-.4-1.03s-.73-.28-1.39-.28h-1.54v2.75h1.5c.72 0 1.2-.12 1.45-.35zM51.56 5.36V7.2h-4.59v1.91h4.13v1.76h-4.13v1.92h4.74v1.83h-6.79V5.36h6.64zM60.09 7.15v7.48h-2.06V7.15h-2.61V5.36h7.28v1.79h-2.61zM70.81 14.64h-2.06v-3.66l-3.19-5.61h2.23l1.99 3.45 1.99-3.45H74l-3.19 5.61v3.66zM83.99 6.19c.65.55.97 1.4.97 2.55s-.33 1.98-1 2.51-1.68.8-3.04.8h-1.23v2.59h-2.06V5.36h3.26c1.42 0 2.45.28 3.1.83zm-1.51 3.65c.25-.28.37-.69.37-1.22s-.16-.92-.48-1.14c-.32-.23-.82-.34-1.5-.34H79.7v3.12h1.38c.68 0 1.15-.14 1.4-.42zM95.85 5.36V7.2h-4.59v1.91h4.13v1.76h-4.13v1.92H96v1.83h-6.79V5.36h6.64z"/></g></svg>
                        </a>
                    </div>
                </template>
            </doc-sidebar>
    
            <div class="grow min-w-0 dark:bg-dark-850">
                <!-- Render "toolbar" template here on api pages --><!-- Render page content -->
                <div class="flex">
                    <div class="min-w-0 p-4 grow md:px-16">
                        <main class="relative pb-12 lg:pt-2">
                            <div class="docs-markdown" id="docs-content">
                                <!-- Rendered if sidebar right is enabled -->
                                <div id="docs-sidebar-right-toggle"></div>
                                <!-- Page content  -->
<doc-anchor-target id="4" class="break-words">
    <h1>
        <doc-anchor-trigger class="header-anchor-trigger" to="#4">#</doc-anchor-trigger>
        <span>4</span>
    </h1>
</doc-anchor-target>
<doc-anchor-target id="asynchronous-programming-with-asyncawait">
    <h1>
        <doc-anchor-trigger class="header-anchor-trigger" to="#asynchronous-programming-with-asyncawait">#</doc-anchor-trigger>
        <span>Asynchronous Programming with Async/Await</span>
    </h1>
</doc-anchor-target>
<p>Welcome to a crucial chapter in your journey through Network Programming using C#, where we delve into Asynchronous programming using <code v-pre>async</code> and <code v-pre>await</code> keywords. As you have been threading your way through the intricacies of network programming, you&#x27;ve learned how to create robust connections, transmit data, and handle various network protocols. Now, we have reached a point where efficiency and responsiveness become paramount. In this chapter, we will explore the power and elegance of C#&#x27;s asynchronous programming paradigms that enhance performance and maintain the responsiveness of applications, even when faced with the most demanding network operations.</p>
<p>By their nature, network applications deal with inherently time-consuming and unpredictable operations. The data may travel across continents, and the time it takes to send a request and receive a response can be significant. This is where asynchronous programming shines. With the <code v-pre>async</code> and <code v-pre>await</code> keywords introduced in C# 5.0, we&#x27;re equipped to write both efficiently and easily read, resembling the straightforwardness of synchronous code while executing non-blocking.</p>
<p>Imagine a scenario where your application must fetch large amounts of data from a remote server or wait for a file to download over a slow connection. Blocking the user interface or consuming thread resources unnecessarily while these operations complete would lead to a subpar user experience and inefficient resource utilization. Through practical examples, we will demonstrate how asynchronous methods allow your application to remain responsive to user interactions by freeing up threads to handle other tasks while waiting for the network operations to complete.</p>
<p>By the end of this chapter, you&#x27;ll understand how to use <code v-pre>async</code> and <code v-pre>await</code> to perform network operations without the complexity traditionally associated with asynchronous programming in C#. You&#x27;ll be able to write code that&#x27;s not only more performant but also simpler and more maintainable. You will learn how to handle exceptions in asynchronous code, report progress, and cancel long-running network operations gracefully.</p>
<p>In this chapter, we are going to cover the following main topics:</p>
<ul>
<li>Introduction to Asynchronous Programming</li>
<li>Understanding Async/Await and Asynchronous Operations</li>
<li>Strategies for Writing Asynchronous Code</li>
</ul>
<doc-anchor-target id="introducing-asynchronous-programming">
    <h2>
        <doc-anchor-trigger class="header-anchor-trigger" to="#introducing-asynchronous-programming">#</doc-anchor-trigger>
        <span>Introducing asynchronous programming</span>
    </h2>
</doc-anchor-target>
<p>Dive into the electrifying world of asynchronous programming, a must-have skill in the .NET 8 and C# 12 universe! Imagine your program as a multitasking superhero, juggling multiple tasks with the grace of a circus performer. This is especially handy in network operations, where tasks like web requests, file munching, or database dances can leave your code twiddling its thumbs, waiting on those slow-moving I/O operations. Old-school synchronous execution? That&#x27;s like waiting in line for coffee—tedious and time-consuming. Asynchronous programming is like having a VIP pass; your code zips around, doing other important stuff while waiting for those network operations to wrap up. It&#x27;s all about keeping things moving and shaking, making your applications snappy and spirited!</p>
<p>Enter the dynamic duo of C# 12: the async and await keywords, your tickets to this thrilling asynchronous adventure. Slap an async badge on a method, and you&#x27;re declaring, &quot;Hey, I&#x27;ve got some async magic up my sleeve!&quot; and transforming it into a task juggler. Then, summon the power of await to elegantly pause these acrobatic tasks, letting your code catch its breath without freezing up the entire show. This harmonious pair streamlines the once daunting tasks of error wrestling, exception taming, and keeping everything in sync. The end game? You, the developer, become a code wizard, crafting clearer, more robust spells—I mean, code—perfect for tackling the intricate quests of network programming in the .NET 8 landscapes. Ready, set, async!</p>
<doc-anchor-target id="historical-context">
    <h3>
        <doc-anchor-trigger class="header-anchor-trigger" to="#historical-context">#</doc-anchor-trigger>
        <span>Historical context</span>
    </h3>
</doc-anchor-target>
<p>Step right up to the thrilling evolution of asynchronous programming in C#! Back then, C# and the .NET framework kicked things off with the basics, using the IAsyncResult pattern and the dynamic duo of BeginInvoke and EndInvoke methods. Sure, they did the job, but boy, was it a rollercoaster of complexity and readability challenges! Picture a jigsaw puzzle where each piece is a callback or a thread management trick – intriguing but oh-so-tricky to piece together, especially when juggling multiple balls in the air with nested or multiple async operations.</p>
<p>Then came the superhero moment with the release of C# 5.0 and .NET Framework 4.5 – enter the game-changing async and await keywords, turning the async coding world upside down (in a good way!). This dynamic duo turned the convoluted script of asynchronous programming into a smooth, engaging narrative, allowing developers to craft their async tales as quickly as penning a simple to-do list. This monumental shift waved goodbye to the old boilerplate-heavy scripts, welcoming a new era where the compiler became the backstage hero, managing the gritty details of thread juggling and callback orchestration. And just like that, asynchronous programming became the star of the C# show, evolving with each new release and proving itself as an indispensable magician in the modern developer&#x27;s toolkit, especially when conjuring up the spells needed for the demanding world of network programming. Let the async adventures begin!</p>
<doc-anchor-target id="the-role-of-asynchronous-programming-in-network-applications">
    <h3>
        <doc-anchor-trigger class="header-anchor-trigger" to="#the-role-of-asynchronous-programming-in-network-applications">#</doc-anchor-trigger>
        <span>The role of asynchronous programming in network applications</span>
    </h3>
</doc-anchor-target>
<p>Asynchronous programming is like the superhero of network application development, swooping in to save the day when data transfer slows to a snail&#x27;s pace. In the bustling world of networking, where applications are constantly chatting, sending, and receiving data across the vast expanses of the internet, the speed and efficiency with which these I/O operations are handled can make or break the user experience. Thanks to the magic of asynchronous programming, developers can weave spells that keep applications lively and responsive, even when faced with the slowest network connections or the heftiest data payloads.</p>
<p>Imagine a bustling city where, instead of traffic jams halting the flow, cars (like data packets) zip around freely, finding alternate routes when the main roads are clogged. That&#x27;s asynchronous programming in action in the network world. Rather than freezing in place, waiting for signals from afar (oh, the agony of synchronous waits!), applications can multitask like pros — juggling user inputs, crunching numbers, and spinning many plates all at once, all while keeping an ear out for that distant data to arrive finally. This keeps things silky smooth for users, who get the real-time reactions they love, whether web surfing, app navigating, or cloud computing.</p>
<p>But wait, there&#x27;s more! Asynchronous programming isn&#x27;t just about keeping the user interface snappy; it&#x27;s also a master of resource efficiency and scalability. By liberating threads from the doldrums of idle waiting, it repurposes them for new tasks, turning potential downtime into productive uptime. This is a game-changer for server-side applications, where the power to juggle multiple requests without breaking a sweat can catapult a service from ho-hum to heroic. Ultimately, asynchronous programming is more than just a feature; it&#x27;s the backbone of modern, efficient, and satisfying network applications.</p>
<doc-anchor-target id="challenges-of-asynchronous-programming">
    <h3>
        <doc-anchor-trigger class="header-anchor-trigger" to="#challenges-of-asynchronous-programming">#</doc-anchor-trigger>
        <span>Challenges of asynchronous programming</span>
    </h3>
</doc-anchor-target>
<p>Asynchronous programming is a thrilling rollercoaster ride in the world of C# and .NET 8! This adventure promises to supercharge your applications with unmatched responsiveness and scalability. But hold onto your hats—along with the rush of speed and efficiency comes a set of challenges that could turn your coding journey into a wild ride.</p>
<p>First up, let&#x27;s tackle the twisty turns of managing asynchronous code. Sure, the async and await keywords in C# are like your personal coding superpowers, making asynchronous operations a breeze. But, just like any superhero, you need to master your powers. Understanding the secrets behind the task-based asynchronous pattern (TAP) and its dance with the .NET runtime is key to conquering villains like pesky errors and debugging dilemmas. Be ready to face the mysterious shadows of asynchronous tasks, where exceptions lurk around delayed corners, making the plot thicker than your average synchronous storyline.</p>
<p>But wait, there&#x27;s more! Imagine your code as a team of synchronized swimmers – elegance meets coordination. But throw in the asynchronous mix, and you might find your swimmers (a.k.a. threads) bumping into each other, causing a splashy mess of race conditions, deadlocks, or, worse, data corruption. Navigating these waters requires a keen understanding of concurrency control, ensuring that every thread knows its place and time. And don&#x27;t get me started on the detective work of testing and debugging asynchronous code – it&#x27;s like trying to solve a mystery where clues are scattered across different timelines. But fear not! With a toolbox filled with advanced debugging gadgets, a keen eye for logging, and a Sherlock Holmes-level understanding of async concepts, you&#x27;ll be cracking cases and smoothing out asynchronous wrinkles in no time. Onward to coding glory!</p>
<doc-anchor-target id="common-pitfalls">
    <h3>
        <doc-anchor-trigger class="header-anchor-trigger" to="#common-pitfalls">#</doc-anchor-trigger>
        <span>Common pitfalls</span>
    </h3>
</doc-anchor-target>
<p>Developers working with asynchronous programming can transform into coding superheroes, navigating the tricky landscapes of network solutions! But beware—even heroes face challenges. In the realm of async/await, there are villains to conquer and pitfalls to avoid to keep your applications flying high in performance, reliability, and maintainability.</p>
<p>First up, our hero encounters the deceptive Misuse Menace – the villain behind the async and await confusion. Some coders, eager to harness the power of async, might sprinkle async like fairy dust on every method, causing chaos and clogging the system with unnecessary overhead. Others might misuse await, turning their nimble asynchronous operations into sluggish, synchronous roadblocks, an actual performance kryptonite!</p>
<p>Then there&#x27;s the sneaky Exception Eel, slithering through unawaited tasks and causing havoc with uncaught exceptions that can crash your application faster than a speeding bullet. Our hero must wield the shield of proper error handling, ensuring that every asynchronous operation is awaited and every exception is caught with the precision of a seasoned defender of code.</p>
<p>Resource management is another battlefield where our hero faces the twin terrors of Resource Leak Lurker and Contention Kraken. These fiends thrive on mismanaged asynchronous operations, leading to drained resources or a tug-of-war over limited assets, slowing our hero&#x27;s application to a crawl.</p>
<p>Let&#x27;s not forget about the Clarity and Debugging Dilemmas, the crafty villains that cloud our hero&#x27;s vision and make code hard to read and debug. But fear not! With the right tools, a keen eye, and a clear understanding of asynchronous principles, our developer superhero can cut through confusion and ensure that their code is as clean and maintainable as the day is long.</p>
<p>So, dear coding crusaders, arm yourselves with knowledge, wield your async and await powers wisely, and remember: in network solutions, understanding and vigilance are your greatest allies in the fight for smooth, efficient, and heroic applications!</p>
<doc-anchor-target id="understanding-the-synchronization-context">
    <h3>
        <doc-anchor-trigger class="header-anchor-trigger" to="#understanding-the-synchronization-context">#</doc-anchor-trigger>
        <span>Understanding the synchronization context</span>
    </h3>
</doc-anchor-target>
<p>Diving into C# network projects and getting the hang of the synchronization context is like learning the secret handshake – it’s critical to keeping your asynchronous operations and team players (like threads and tasks) in perfect harmony. Picture this: in the .NET world, the synchronization context is the backstage manager ensuring that all your work items, messages, or event handlers make a grand re-entrance to the right scene or thread – especially crucial for those spotlight moments in UI updates in Windows Forms or WPF apps. It’s all about timing and ensuring everything syncs up smoothly with network responses, dodging those pesky show spoilers like race conditions or the dreaded UI missteps from backstage (non-UI thread) interventions.</p>
<p>Here’s the twist: leaning too much on the synchronization context, particularly in the bustling backstage of server-side applications like ASP.NET, might cramp your app’s style, leading to awkward performance, slow dances and scalability wallflowers. Here’s a pro tip: when your code’s not busy with UI touch-ups or threading VIPs, consider going incognito with ConfigureAwait(false). It’s like telling your code, “Psst, meet me directly at the after-party, skip the synchronization context formalities.” This nifty move can streamline your performance and keep those deadlock party poopers off the guest list. So, getting the synchronization context vibe just right can make your asynchronous C# network shindig more efficient and the talk of the town in scalability and maintenance circles! We will learn more about ConfigureAwait later in the chapter.</p>
<doc-anchor-target id="understanding-asyncawait-and-asynchronous-operations">
    <h2>
        <doc-anchor-trigger class="header-anchor-trigger" to="#understanding-asyncawait-and-asynchronous-operations">#</doc-anchor-trigger>
        <span>Understanding async/await and asynchronous operations</span>
    </h2>
</doc-anchor-target>
<p>Let&#x27;s chat (and code) about how the incredible duo of async/await has totally changed the game for .NET developers. Gone are the days of wrestling with clunky, error-riddled ways of doing things asynchronously. Now, it&#x27;s all about cruising down the smooth highway of code with a fresh and friendly approach. Just slap the async label on a method to signal it&#x27;s got some asynchronous magic up its sleeve, and it&#x27;ll hand you back a Task or Task<T> like a secret handshake. Then, sprinkle some await magic when calling these methods, and watch your current method take a chill pill, pausing gracefully without throwing a tantrum and freezing up your thread.</p>
<doc-anchor-target id="asyncawait-fundamentals">
    <h3>
        <doc-anchor-trigger class="header-anchor-trigger" to="#asyncawait-fundamentals">#</doc-anchor-trigger>
        <span>Async/await fundamentals</span>
    </h3>
</doc-anchor-target>
<p>In the fabulous world of C# 12, async and await are the dynamic duo of asynchronous programming. They&#x27;re here to help you clean up your act, making your code neater and a breeze to read, especially when you&#x27;ve got all those wait-worthy operations like network calls or file I/O without putting your executing thread to sleep.</p>
<p>When you slap async onto a method, you give it a special badge that says, &quot;Yep, I&#x27;m the patient type.&quot; This means the method is set to return a Task or Task<T>, like a promise for work that&#x27;s still in the pipeline. Enter await, the cool sidekick within these async methods; it tells your code to chill out for a second until the Task at hand is all done without the dreaded thread lock-up. This lets your app juggle multiple things simultaneously, keeping it snappy and responsive.</p>
<p>This power couple, async and await, is all about making your life easier when dealing with asynchronous shenanigans. They help keep your code organized and humming along nicely, boosting performance and keeping users happy. How cool is that?</p>
<doc-anchor-target id="the-async-modifier">
    <h4>
        <doc-anchor-trigger class="header-anchor-trigger" to="#the-async-modifier">#</doc-anchor-trigger>
        <span>The async modifier</span>
    </h4>
</doc-anchor-target>
<p>Imagine the async keyword in C# as a friendly magician in your coding toolbox. When you&#x27;re stuck in the slow-motion world of synchronous code, where every task waits in line like shoppers before a store opens, async waves its magic wand to keep things moving smoothly. Instead of standing around waiting for one task to finish before starting another, async helps your code do multiple things at once, like a skilled chef juggling different dishes. Now, let&#x27;s see the magic in action!</p>
<p>Without async (the world without magic):</p>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-csharp"><code v-pre class="language-csharp">using System;
using System.Threading;

public class BeforeAsync
{
    private int CalculateSum()
    {
        Thread.Sleep(5000); // Pretending to crunch some serious numbers for 5 seconds.
        return 42; // The universe's answer to everything, obviously.
    }

    public void ShowSum()
    {
        int sum = CalculateSum(); // Waiting...waiting...
        Console.WriteLine($&quot;Calculated Sum: {sum}&quot;);
    }
}

// Usage:
var beforeAsync = new BeforeAsync();
beforeAsync.ShowSum(); // Time seems to stand still...</code></pre>
</doc-codeblock></div>
<p>Here, your program is like a patient in a doctor&#x27;s waiting room, just sitting and twiddling its thumbs until the CalculateSum method graciously decides to return.</p>
<p>With async (welcome to the magic show!):</p>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-csharp"><code v-pre class="language-csharp">public class AfterAsync
{
    private async Task&lt;int&gt; CalculateSumAsync()
    {
        await Task.Delay(5000); // Simulates crunching numbers asynchronously.
        return 42; // Still the answer to everything, but faster!
    }

    public async Task ShowSumAsync()
    {
        int sum = await CalculateSumAsync(); // Look at me! I can do other things while waiting!
        Console.WriteLine($&quot;Calculated Sum: {sum}&quot;);
    }
}

// Usage:
var afterAsync = new AfterAsync();
await afterAsync.ShowSumAsync(); // Whoosh! Off to multitask-land!</code></pre>
</doc-codeblock></div>
<p>In this exhilarating async universe, your program can now send off the CalculateSumAsync method on its merry way and get on with other tasks instead of sitting idly by. When the method is done, it&#x27;ll nudge your program, saying, &quot;Hey, I’ve got your answer!&quot; This is efficiency at its finest, turning your code from a snooze fest into a productivity powerhouse. Welcome to the future, where your code doesn&#x27;t just run; it sprints.</p>
<doc-anchor-target id="the-await-keyword">
    <h4>
        <doc-anchor-trigger class="header-anchor-trigger" to="#the-await-keyword">#</doc-anchor-trigger>
        <span>The await keyword</span>
    </h4>
</doc-anchor-target>
<p>Dive into the fantastic world of the await modifier in C# and .NET, where your code dances through tasks with the grace of a ballet star, skipping over the boring waits and making efficiency look effortless. Imagine await as the magical word that pauses your favorite TV show (a task) while you run to grab a snack, ensuring you don&#x27;t miss a single moment. It tells your program, &quot;Hey, chill for a sec, I&#x27;ve got some stuff to handle, but don&#x27;t worry, you won&#x27;t even notice I&#x27;m gone!&quot;</p>
<p>Before the era of await, here&#x27;s how our code drama unfolded:</p>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-csharp"><code v-pre class="language-csharp">public class NoAwaitLand
{
    private string MakeTea()
    {
        Thread.Sleep(3000); // Simulating the time it takes to make tea.
        return &quot;Tea is ready!&quot;;
    }

    public void EnjoyTea()
    {
        string tea = MakeTea(); // Time drags... and drags...
        Console.WriteLine(tea); // Finally, tea time, but your show is over!
    }
}

// Usage:
var noAwaitLand = new NoAwaitLand();
noAwaitLand.EnjoyTea(); // Sigh... Waiting is such sweet sorrow.</code></pre>
</doc-codeblock></div>
<p>In this world, making tea means missing the crucial plot twists of your show. Your code, like you, sits and waits, wasting precious moments.</p>
<p>Now, let&#x27;s sprinkle some await magic into the mix:</p>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-csharp"><code v-pre class="language-csharp">public class AwaitLand
{
    private async Task&lt;string&gt; MakeTeaAsync()
    {
        await Task.Delay(3000); // Like putting the kettle on and walking away.
        return &quot;Tea is ready, and you didn't miss a thing!&quot;;
    }

    public async Task EnjoyTeaAsync()
    {
        string tea = await MakeTeaAsync(); // The magic happens: pause and resume!
        Console.WriteLine(tea); // Tea time aligns with your show's commercial break!
    }
}

// Usage:
var awaitLand = new AwaitLand();
await awaitLand.EnjoyTeaAsync(); // Look at you, multitasking like a pro!</code></pre>
</doc-codeblock></div>
<p>With the power of await, your code now makes tea while still keeping up with every twist and turn of your TV show. No more missed moments, no more waiting around—just pure, uninterrupted productivity. The await modifier turns your tasks into background ninjas, completing their missions without pulling you away from what matters. Welcome to the future, where your code keeps up with your life&#x27;s pace, making every second count!</p>
<doc-anchor-target id="strategies-for-writing-asynchronous-code">
    <h2>
        <doc-anchor-trigger class="header-anchor-trigger" to="#strategies-for-writing-asynchronous-code">#</doc-anchor-trigger>
        <span>Strategies for writing asynchronous code</span>
    </h2>
</doc-anchor-target>
<p>Diving into the world of asynchronous code in C# can be like unlocking a new level in a video game – exciting but initially tricky. Writing asynchronous code is all about doing multiple things at once without getting in your way. Imagine you&#x27;re in a kitchen making breakfast: toast toasting, coffee brewing, and eggs frying. In the coding world, instead of waiting for each task to finish before starting the next, you get them all going simultaneously. That&#x27;s the magic of async programming – it keeps your app&#x27;s kitchen running smoothly, so you&#x27;re not just staring at the toaster!</p>
<p>But, just like in cooking, there&#x27;s an art to juggling all those tasks without burning your breakfast. Strategies for writing good asynchronous code involve:</p>
<ul>
<li>Understanding when and how to use those nifty async and await keywords.</li>
<li>Managing tasks efficiently.</li>
<li>Avoiding common pitfalls like deadlocks or resource starvation.</li>
</ul>
<p>Think of it as having suitable recipes and kitchen tools at your disposal. By mastering these strategies, you can whip up a fast, responsive application that handles operations like a well-oiled machine, all while keeping the user experience as smooth as a perfectly brewed cup of coffee. Let&#x27;s dive in and turn up the heat (but only a little) on writing awesome asynchronous code!</p>
<doc-anchor-target id="know-when-to-use-asyncawait">
    <h3>
        <doc-anchor-trigger class="header-anchor-trigger" to="#know-when-to-use-asyncawait">#</doc-anchor-trigger>
        <span>Know When to Use async/await</span>
    </h3>
</doc-anchor-target>
<p>So when do we as software developers break out the async and await superheroes in our C# networking software. Picture this: your application is like a bustling coffee shop. Your customers are your app&#x27;s users, and the coffee orders are your network requests. Now, in a traditional, synchronous world, each barista (let&#x27;s call them threads) can only handle one order at a time. If someone orders a fancy, time-consuming latte, everyone else waits. Not fun, right?</p>
<p>Enter async and await your dynamic duo to handle the morning rush. By implementing these guys in your networking code, you&#x27;re opening up multiple coffee stations. Now, while one barista is meticulously crafting that latte (think of a time-consuming network request), another can start on the next order. In technical terms, you&#x27;re not blocking the main thread while waiting for a network response. This keeps your application&#x27;s UI snappy and responsive, improving the user experience.</p>
<p>But when exactly should you unleash this power? Here are a few pointers:</p>
<ul>
<li><strong>Long-running network calls</strong>: Async and await should be your go-to whenever you&#x27;re making API calls, downloading files, or performing any network operation that takes more than a blink of an eye. They prevent your app from freezing up while waiting for the network to respond.</li>
<li><strong>UI responsiveness</strong>: Async programming is crucial if your application has a user interface and you need to maintain its responsiveness while performing network operations. It ensures that your app can still handle user interactions, like button clicks or scrolling, even when it&#x27;s busy fetching data from the web.</li>
<li><strong>Scalability</strong>: When writing server-side code, such as for a web service, using async and await can improve scalability. It lets your server handle more requests simultaneously by not tying up threads waiting for I/O operations to complete.</li>
</ul>
<p>However, it&#x27;s not always rainbows and butterflies. Remember, using async and await is optional for quick, in-and-out operations, and it can complicate your code if used excessively or unnecessarily. Plus, it&#x27;s not a silver bullet for performance issues – it&#x27;s about efficiency and responsiveness.</p>
<p>So, think of async and await as your special tools for keeping the coffee shop running smoothly, ensuring every customer (user) leaves happy and maybe even a little impressed by the service. Use them wisely, and your networking software will handle operations like a dream without leaving your users hanging.</p>
<doc-anchor-target id="async-method-design">
    <h3>
        <doc-anchor-trigger class="header-anchor-trigger" to="#async-method-design">#</doc-anchor-trigger>
        <span>Async method design</span>
    </h3>
</doc-anchor-target>
<p>Let&#x27;s look at designing async methods in C#. Think of async methods as your own personal team of background assistants in the world of C#. They&#x27;re like those helpful elves from fairy tales, doing the heavy lifting in the background while you keep the front of the shop (your main application) running smoothly and keeping the customers (users) happy. Async methods allow your app to handle tasks like accessing the web, working with files, or any other time-consuming operations without freezing up your user interface or making your application feel stuck in the mud.</p>
<p>Designing these methods is like planning a well-organized workspace. You want everything to be efficient and in the right place. In C# land, this means knowing when to use the async keyword, applying await to pause things gracefully, and figuring out the return types (usually Task or Task<T>) that fit your needs. But it&#x27;s not just about slapping async and await everywhere like they&#x27;re going out of style. It&#x27;s about crafting your methods to improve the responsiveness of your applications while keeping your code clean and understandable. It&#x27;s like setting up your kitchen for a big dinner party – everything needs to be ready to go so you can handle whatever the evening throws at you without breaking a sweat.</p>
<doc-anchor-target id="async-all-the-way-down">
    <h4>
        <doc-anchor-trigger class="header-anchor-trigger" to="#async-all-the-way-down">#</doc-anchor-trigger>
        <span>Async all the way down</span>
    </h4>
</doc-anchor-target>
<p>Imagine you&#x27;re building a network of pipes in a super futuristic city. In this city, water (data) must flow smoothly and without interruption to keep everyone happy. In this analogy, async and await are your high-tech tools for ensuring that water flows efficiently without any hiccups or blockages.</p>
<p>When do you gear up and go full async mode? The rule of thumb in the async world is pretty much &quot;if you start async, you stay async,&quot; especially in network operations. This is like saying, if you start laying down those high-tech pipes in one area (initiating an async operation), you&#x27;d better be consistent and lay them all the way down to where the water needs to go (complete the operation and all its related tasks asynchronously).</p>
<p>For example, if you&#x27;re making HTTP calls to a remote server, fetching large files, or waiting for responses from a database, these are perfect scenarios for going async from top to bottom. You don&#x27;t want your app&#x27;s user interface freezing up or your backend services getting clogged while waiting for responses. By using async and await, you allow other operations to continue smoothly in parallel, like letting traffic flow in other lanes while one lane is temporarily closed.</p>
<p>But remember, &quot;async all the way down&quot; is not a free pass to slap async and await on every method, like bumper stickers. Use them where it makes sense – where blocking can occur and affect responsiveness or performance. It&#x27;s all about keeping the data flowing smoothly without unnecessary hold-ups.</p>
<p>And here&#x27;s a pro tip: Only mix synchronous and asynchronous code with a good reason. This can lead to the dreaded deadlocks and reduce the efficiency of your networking software. Think of it as ensuring all your pipes are compatible and well-connected to prevent leaks and have a steady flow.</p>
<p>In conclusion, when building networking software in C#, going &quot;async all the way down&quot; means committing to a strategy that maximizes efficiency and responsiveness from the initial user request to the final outcome. Like in our futuristic city, ensuring a consistent and uninterrupted flow keeps everything running smoothly, making for a happier, more productive environment.</p>
<doc-anchor-target id="avoid-async-void">
    <h4>
        <doc-anchor-trigger class="header-anchor-trigger" to="#avoid-async-void">#</doc-anchor-trigger>
        <span>Avoid async Void</span>
    </h4>
</doc-anchor-target>
<p>Dive into the intriguing quirk of the async world: the notorious async void methods in C#. Think of async void as that one friend who says they&#x27;ll help with your big party (your app), then disappears when the first guests arrive (runtime). Sure, they meant well when they offered to help, but their vanishing act leaves you scrambling to cover all the bases yourself.</p>
<p>In C# land, we usually see async void used for event handlers because, historically, that&#x27;s been the convention. But outside of that, using async void is like walking on thin ice – it can lead to some pretty slippery situations. Why? Because async void methods are challenging to handle when it comes to exceptions. If something goes wrong in an async void method, it&#x27;s not contained nicely like in Task or Task<T>; it can crash your whole application. They&#x27;re like rogue agents causing chaos without a way to report back correctly.</p>
<p>Instead, it would be best to stick to async Task for your asynchronous methods. This way, if your async operation hits a snag, you can elegantly catch and handle the exception, preventing your app from crashing and burning. Think of async Task as the reliable buddy who not only shows up to help with the party but also cleans up if anything goes wrong.</p>
<p>So, steer clear of async void unless you&#x27;re dealing with event handlers. Embrace async Task instead. It&#x27;s like choosing a dependable, all-terrain vehicle over a flashy, unreliable sports car for a cross-country road trip. Sure, the sports car looks cool, but you want the reliability and safety of the SUV to ensure you reach your destination smoothly without unexpected breakdowns. Keep your async journey safe, predictable, and under control with async Task, and leave async void for those rare, specific scenarios where necessary.</p>
<doc-anchor-target id="task-handling">
    <h3>
        <doc-anchor-trigger class="header-anchor-trigger" to="#task-handling">#</doc-anchor-trigger>
        <span>Task handling</span>
    </h3>
</doc-anchor-target>
<p>Tasks in C# are where Async programming gets cool and modern, like switching from snail mail to instant messaging. When you use Async programming, you tell your C# application, &quot;Hey, why don&#x27;t you run this time-consuming task over there and just ping me when done?&quot; This way, your app stays calm when handling big tasks like downloading files or querying a database. Instead, it stays responsive, keeping users happy because they can continue doing things without interruption.</p>
<p>We will look at Tasks, the MVPs of Async programming in C#. A Task is a promise for some work that will be completed in the future. Think of it as ordering your coffee at a busy café. You get a number (the Task), and while you wait for your number to be called, you&#x27;re free to scroll through your phone or chat with a friend. You can enjoy the results once your coffee (or Task) is ready. Tasks with async and await keywords in C# make writing asynchronous code as smooth as your favorite latte. It&#x27;s all about keeping things moving efficiently without the dreaded app freezes or slowdowns. Welcome to the async lifestyle – your code (and users) will thank you!</p>
<doc-anchor-target id="return-tasks-from-asynchronous-methods">
    <h4>
        <doc-anchor-trigger class="header-anchor-trigger" to="#return-tasks-from-asynchronous-methods">#</doc-anchor-trigger>
        <span>Return tasks from asynchronous methods</span>
    </h4>
</doc-anchor-target>
<p>Next, we will get a coding example for the dazzling world of asynchronous programming in C#, where Tasks, async, and await form the superhero team that saves the day from the clutches of sluggish applications! Imagine your code as a bustling city. In the old days, without Tasks, it was like having only one road from point A to B, causing traffic jams whenever something big happened (like fetching data from the web). Everyone had to wait in line, tapping their fingers impatiently.</p>
<p>Here&#x27;s what the code looks like in that one-lane world, a synchronous slog:</p>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-csharp"><code v-pre class="language-csharp">public class DigitalKitchen
{
    private string BakeCake()
    {
        Console.WriteLine(&quot;Cake baking started.&quot;);
        Thread.Sleep(4000); // Simulating baking time.
        Console.WriteLine(&quot;Cake is ready!&quot;);
        return &quot;Chocolate Cake&quot;;
    }

    private string PrepareSalad()
    {
        Console.WriteLine(&quot;Salad preparation started.&quot;);
        Thread.Sleep(2000); // Simulating chopping and mixing time.
        Console.WriteLine(&quot;Salad is ready!&quot;);
        return &quot;Greek Salad&quot;;
    }

    private string BrewCoffee()
    {
        Console.WriteLine(&quot;Coffee brewing started.&quot;);
        Thread.Sleep(3000); // Simulating brewing time.
        Console.WriteLine(&quot;Coffee is ready!&quot;);
        return &quot;Espresso&quot;;
    }

    public void PrepareDinner()
    {
        // Each method completes before the next starts.
        string cake = BakeCake();
        string salad = PrepareSalad();
        string coffee = BrewCoffee();

        Console.WriteLine($&quot;Dinner is ready with: {cake}, {salad}, {coffee}&quot;);
    }
}

// Usage:
var kitchen = new DigitalKitchen();
kitchen.PrepareDinner();</code></pre>
</doc-codeblock></div>
<p>But with async, await, and Tasks, we introduce highways, flyovers, and express lanes into our city! Your code can now handle multiple things at once, like a pro multitasker:</p>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-csharp"><code v-pre class="language-csharp">public class DigitalKitchen
{
    private async Task&lt;string&gt; BakeCakeAsync()
    {
        Console.WriteLine(&quot;Cake baking started.&quot;);
        await Task.Delay(4000); // Simulating baking time.
        Console.WriteLine(&quot;Cake is ready!&quot;);
        return &quot;Chocolate Cake&quot;;
    }

    private async Task&lt;string&gt; PrepareSaladAsync()
    {
        Console.WriteLine(&quot;Salad preparation started.&quot;);
        await Task.Delay(2000); // Simulating chopping and mixing time.
        Console.WriteLine(&quot;Salad is ready!&quot;);
        return &quot;Greek Salad&quot;;
    }

    private async Task&lt;string&gt; BrewCoffeeAsync()
    {
        Console.WriteLine(&quot;Coffee brewing started.&quot;);
        await Task.Delay(3000); // Simulating brewing time.
        Console.WriteLine(&quot;Coffee is ready!&quot;);
        return &quot;Espresso&quot;;
    }

    public async Task PrepareDinnerAsync()
    {
        // Starting all tasks without waiting for any to complete.
        var cakeTask = BakeCakeAsync();
        var saladTask = PrepareSaladAsync();
        var coffeeTask = BrewCoffeeAsync();

        // Now, await all tasks, effectively not waiting for each individually but letting them run concurrently.
        var dinnerItems = await Task.WhenAll(cakeTask, saladTask, coffeeTask);
        
        Console.WriteLine($&quot;Dinner is ready with: {string.Join(&quot;, &quot;, dinnerItems)}&quot;);
    }
}

// Usage:
var kitchen = new DigitalKitchen();
await kitchen.PrepareDinnerAsync();</code></pre>
</doc-codeblock></div>
<p>Our DigitalKitchen doesn&#x27;t pause at each method call in this async symphony. Instead, it fires all three – baking a cake, preparing a salad, and brewing coffee – in a non-blocking fashion. Only when all three tasks are sent off to work their magic does it wait for all of them to finish. This approach showcases the power of asynchronous programming in C#,  where our digital chef multitasks efficiently, ensuring a delightful dinner is ready in record time without the waits dragging down the kitchen&#x27;s performance.</p>
<doc-anchor-target id="avoid-premature-await">
    <h4>
        <doc-anchor-trigger class="header-anchor-trigger" to="#avoid-premature-await">#</doc-anchor-trigger>
        <span>Avoid premature await</span>
    </h4>
</doc-anchor-target>
<p>Let us look at more high-flying adventures in Asyncville, where our C# superhero coders combat the sneaky villain known as Premature Await! This dastardly foe can trick heroes into halting their heroic deeds too soon, bogging down the bustling city with unnecessary waiting.</p>
<p>In the world without this awareness, our heroes might fall into the trap like so:</p>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-csharp"><code v-pre class="language-csharp">public async Task&lt;int&gt; BattleVillainsAsync()
{
    await Task.Delay(2000); // Our hero jumps into action immediately!
    return 5; // Number of villains vanquished
}

public async Task&lt;int&gt; SaveCiviliansAsync()
{
    await Task.Delay(2000); // Diving in to save the day without a second thought!
    return 10; // Number of civilians saved
}

public async Task HeroicDeeds()
{
    int villainsVanquished = await BattleVillainsAsync(); // Await the battle's end...
    int civiliansSaved = await SaveCiviliansAsync(); // ...then await the rescue!
    Console.WriteLine($&quot;Villains vanquished: {villainsVanquished}, Civilians saved: {civiliansSaved}&quot;);
}</code></pre>
</doc-codeblock></div>
<p>Here, our eager superhero, with all the best intentions, jumps the gun and uses await unnecessarily early. They&#x27;re stuck in place, staring at their watch while the villainous Task Delay roams free, slowing down the city&#x27;s rhythm.</p>
<p>But fear not, for our heroes learn and adapt:</p>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-csharp"><code v-pre class="language-csharp">public async Task&lt;int&gt; BattleVillainsAsync()
{
    await Task.Delay(2000); // Battling villains in an epic showdown
    return 5; // Villains vanquished
}

public async Task&lt;int&gt; SaveCiviliansAsync()
{
    await Task.Delay(2000); // Heroically saving civilians
    return 10; // Civilians saved
}

public async Task HeroicDeedsDoneRight()
{
    var battleTask = BattleVillainsAsync(); // Start the battle, but don't wait yet!
    var saveTask = SaveCiviliansAsync(); // Start rescues, too—no time to lose!

    // Now, await both tasks, efficiently managing our hero's time:
    int villainsVanquished = await battleTask;
    int civiliansSaved = await saveTask;
    Console.WriteLine($&quot;Villains vanquished: {villainsVanquished}, Civilians saved: {civiliansSaved}&quot;);
}</code></pre>
</doc-codeblock></div>
<p>In this upgraded scenario, our superhero deftly manages their tasks. They set off a drone (initiate the Task) and continue gathering valuable intel or helping citizens while the drone does its reconnaissance. Only when all pieces are in place do they finally await, springing into action at the optimal moment. No time is wasted; the city thrives under their vigilant watch.</p>
<doc-anchor-target id="error-handling">
    <h3>
        <doc-anchor-trigger class="header-anchor-trigger" to="#error-handling">#</doc-anchor-trigger>
        <span>Error handling</span>
    </h3>
</doc-anchor-target>
<p>In the world of Async programming, things move smoothly like a well-oiled machine, even when you&#x27;re handling a bunch of tasks at once. Imagine sending your robots to do chores while you chill out; that&#x27;s async for you! But, as with all great powers, there&#x27;s a catch – handling the unexpected. Yep, I&#x27;m talking about errors. Like tripping over that sneaky rug, your async tasks can stumble over issues, and you must be ready to catch them gracefully.</p>
<p>In the async world of C#, error handling isn&#x27;t just about slapping on a try-catch and calling it a day. It&#x27;s more like being a savvy superhero anticipating the villain&#x27;s moves. When you use async and await, exceptions get wrapped up and delivered back to you when the task is awaited. This means you can catch those exceptions right where they happen, in the comfort of your async method, and deal with them in a way that makes sense for your app&#x27;s flow and user experience.</p>
<p>But remember, with great power comes great responsibility. Handling errors in async programming means staying vigilant about where and how you await tasks and not letting any exceptions slip through the cracks unnoticed. It&#x27;s all about keeping your code&#x27;s async flow smooth, responsive, and, most importantly, resilient to the bumps along the way. So, gear up, prepare your error-handling strategies, and make your async C# code fast, efficient, tough, and dependable!</p>
<doc-anchor-target id="exception-handling-in-async-code">
    <h4>
        <doc-anchor-trigger class="header-anchor-trigger" to="#exception-handling-in-async-code">#</doc-anchor-trigger>
        <span>Exception handling in async code</span>
    </h4>
</doc-anchor-target>
<p>Let&#x27;s dive back into the quirky world of async programming in C# with a twist – handling those sneaky errors! Think of your async methods like a team of superheroes. Each has its task, flying around the city (your program) keeping peace and order. But sometimes, they encounter supervillains (errors) that try to throw a wrench in their well-laid plans.</p>
<p>Without proper error handling, it&#x27;s like sending your heroes out without their super gear:</p>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-csharp"><code v-pre class="language-csharp">public async Task SaveTheCityAsync()
{
    await Task.Run(() =&gt; { throw new Exception(&quot;Oops... Villain spotted!&quot;); });
    // The exception goes uncaught, and our hero falls from the sky!
}</code></pre>
</doc-codeblock></div>
<p>In this scenario, our unsuspecting hero runs headfirst into trouble, and the whole mission falls apart. The city (your program) descends into chaos because the error (villain) wasn&#x27;t handled properly.</p>
<p>Now, let&#x27;s suit up correctly with some error-handling armor:</p>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-csharp"><code v-pre class="language-csharp">public async Task SaveTheCityAsync()
{
    try
    {
        await Task.Run(() =&gt; { throw new Exception(&quot;Villain attack!&quot;); });
    }
    catch (Exception ex)
    {
        Console.WriteLine($&quot;No worries, caught the villain: {ex.Message}&quot;);
        // Our hero catches the villain and saves the day!
    }
}</code></pre>
</doc-codeblock></div>
<p>In this upgraded version, our hero is prepared. When the villain pops up, they catch them in a net of error-handling logic and save the day, all without breaking a sweat. The city stays safe, the program runs smoothly, and peace is restored, thanks to the power of adequately handled async errors. Remember, in the async world of C#, always wear your error-handling suit – it&#x27;s the best defense against the unexpected!</p>
<p>In the vibrant landscape of asynchronous programming in C#, programmers can encounter several specialized types of exceptions beyond the usual suspects of runtime exceptions. These unique challenges require their strategies and capes to conquer.</p>
<p>First off, meet the <code v-pre>TaskCanceledException</code>. This tricky character pops up when an asynchronous operation is canceled midway. Imagine sending your superhero on a mission, only to call them back home because the villain turned out to be a false alarm:</p>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-csharp"><code v-pre class="language-csharp">public async Task PerformTask(CancellationToken cancellationToken)
{
    try
    {
        await Task.Delay(5000, cancellationToken);
    }
    catch (TaskCanceledException)
    {
        Console.WriteLine(&quot;Task was canceled, retreat!&quot;);
    }
}</code></pre>
</doc-codeblock></div>
<p>In this scenario, our hero gets the &quot;abort mission&quot; signal and gracefully bows out, thanks to the <code v-pre>TaskCanceledException</code>.</p>
<p>Next up is the <code v-pre>AggregateException</code>. This one&#x27;s a crowd — literally. It&#x27;s like throwing a party and suddenly every minor villain in town decides to crash it. <code v-pre>AggregateException</code> occurs when multiple exceptions are thrown within a single task, often seen with <code v-pre>Task.WhenAll</code>:</p>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-csharp"><code v-pre class="language-csharp">public async Task HandleMultipleTasksAsync()
{
    var tasks = new List&lt;Task&gt;
    {
        Task.Run(() =&gt; throw new InvalidOperationException(&quot;Invalid operation!&quot;)),
        Task.Run(() =&gt; throw new NullReferenceException(&quot;Nothing here!&quot;))
    };

    try
    {
        await Task.WhenAll(tasks);
    }
    catch (AggregateException ex)
    {
        foreach (var innerEx in ex.InnerExceptions)
        {
            Console.WriteLine($&quot;Caught villain: {innerEx.Message}&quot;);
        }
    }
}</code></pre>
</doc-codeblock></div>
<p>Here, our hero faces not one but multiple challenges at once. Thanks to <code v-pre>AggregateException</code>, they can tackle them all in a single heroic swoop.</p>
<p>Lastly, let&#x27;s remember the sneaky <code v-pre>OperationCanceledException</code>, similar to <code v-pre>TaskCanceledException</code> but broader, covering non-task cancellations. It&#x27;s like getting ready to launch the grand finale at your fireworks show, only to find out the whole event has been called off:</p>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-csharp"><code v-pre class="language-csharp">public async Task CheckWeatherAsync(CancellationToken cancellationToken)
{
    try
    {
        await Task.Run(() =&gt; cancellationToken.ThrowIfCancellationRequested());
    }
    catch (OperationCanceledException)
    {
        Console.WriteLine(&quot;Weather check canceled, pack up the picnic!&quot;);
    }
}</code></pre>
</doc-codeblock></div>
<p>In this tale, our hero gets a heads-up to cancel the picnic plans due to stormy weather on the horizon, dodging a wet and windy disaster.</p>
<p>By understanding and handling these exceptions, programmers can ensure their async C# adventures end in triumph, not tragedy. So, gear up bravely with knowledge and code to the async wilderness!</p>
<doc-anchor-target id="efficient-use-of-resources">
    <h3>
        <doc-anchor-trigger class="header-anchor-trigger" to="#efficient-use-of-resources">#</doc-anchor-trigger>
        <span>Efficient use of resources</span>
    </h3>
</doc-anchor-target>
<p>Imagine being able to cook dinner, do laundry, and water the plants simultaneously without breaking a sweat. That&#x27;s what async programming can do for your applications. It lets your code perform multiple tasks simultaneously, like sending emails, fetching data, or saving files, without making the entire application sit and wait for each task to finish. This magic trick keeps your app responsive and snappy, making users wonder if you&#x27;ve employed some digital wizardry!</p>
<p>But here&#x27;s the kicker: while juggling all these tasks, we must be mindful not to waste resources. It&#x27;s like having all your appliances running efficiently without blowing a fuse. By using async programming smartly, you can avoid clogging up your application&#x27;s arteries with unnecessary work. It&#x27;s all about sending off those tasks to do their thing in the background while your main application hums along, unaffected. This way, you can serve more users, handle more data, and create a smoother experience without needing a supercomputer. Ready to dive in? Let&#x27;s turn that efficiency dial up to eleven and get your C# applications performing like a well-oiled, multitasking machine!</p>
<doc-anchor-target id="configureawaitfalse">
    <h4>
        <doc-anchor-trigger class="header-anchor-trigger" to="#configureawaitfalse">#</doc-anchor-trigger>
        <span>ConfigureAwait(false)</span>
    </h4>
</doc-anchor-target>
<p>Alright, superheroes of the coding world, gather around! It&#x27;s time to master a secret move in async programming in C#: <code v-pre>ConfigureAwait(false)</code>. Think of this as your gadget for zipping through tasks without getting tangled in busy city traffic (a.k.a. the main thread).</p>
<p>When you&#x27;re out there saving the digital world with your async superpowers, you often operate on the main thread – the bustling main street of your application. But not all heroic deeds need the spotlight of the city center. <code v-pre>ConfigureAwait(false)</code> tells your async operations, &quot;Hey, it&#x27;s cool; you can finish up this mission in the back alleys.&quot; This means once they complete their task, they don&#x27;t have to report back on the main thread; they can send a signal from wherever they are. It&#x27;s perfect for background tasks without updating the UI or accessing the main thread-specific context.</p>
<p>Let’s see our hero in action, first without <code v-pre>ConfigureAwait(false)</code>:</p>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-csharp"><code v-pre class="language-csharp">public async Task SaveTheWorldAsync()
{
    // Our hero does something important on a background thread...
    await Task.Delay(1000); // Wait here, blocking the main street!
    // Back to saving the world, but we're causing traffic jams on main street!
}</code></pre>
</doc-codeblock></div>
<p>Here, our hero returns to the main thread after completing their secret mission, causing unnecessary delays and congestion.</p>
<p>Now, with our secret gadget <code v-pre>ConfigureAwait(false)</code>:</p>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-csharp"><code v-pre class="language-csharp">public async Task SaveTheWorldAsync()
{
    // Our hero starts their mission...
    await Task.Delay(1000).ConfigureAwait(false); // This time, no need to return to the main street.
    // Mission continues smoothly, no traffic jams, and the world gets saved faster!
}</code></pre>
</doc-codeblock></div>
<p>Using <code v-pre>ConfigureAwait(false)</code>, our superhero can continue their noble deeds without having to swing back to Main Street, keeping the city&#x27;s traffic flowing smoothly and saving the day more efficiently. Just remember, great power requires great responsibility: only use this power when you&#x27;re sure you don&#x27;t need to return to the main thread, like updating the UI or accessing thread-bound resources. Now, go forth and code with agility and efficiency, my C# crusaders!</p>
<doc-anchor-target id="concurrency-and-synchronization">
    <h3>
        <doc-anchor-trigger class="header-anchor-trigger" to="#concurrency-and-synchronization">#</doc-anchor-trigger>
        <span>Concurrency and synchronization</span>
    </h3>
</doc-anchor-target>
<p>The team of superheroes: each has its own set of skills and tasks, but they must work together to save the city from chaos. This is your application, managing multiple operations simultaneously without tripping over its own cape. Async programming lets your heroes (methods) battle different villains (tasks) at the same time, without waiting for one to finish before starting another, keeping the city (user experience) safe and peaceful.</p>
<p>But with great power comes great responsibility. This is where Concurrency and Synchronization enter our comic book story. Concurrency is like efficiently organizing a team of superheroes. You wouldn&#x27;t want two heroes to show up to defuse the same bomb while another threat goes unchallenged, right? Similarly, in coding, we need to ensure our tasks are running simultaneously but not stepping on each other&#x27;s toes, especially when they need to share resources like data and files.</p>
<p>And then, there&#x27;s synchronization - the secret sauce to ensuring our superheroes work well together and combine their powers effectively. It&#x27;s all about timing and coordination, making sure that shared resources are accessed in an orderly manner, avoiding the perils of data corruption or unexpected behavior. Imagine our heroes using walkie-talkies to coordinate their moves, ensuring they&#x27;re not colliding or causing havoc unintentionally. In C#, this could mean using locks, semaphores, or other synchronization techniques to keep data safe and operations running smoothly. So, let&#x27;s dive into this thrilling world, where managing async operations and concurrency is the key to keeping our digital city thriving under the vigilant watch of our code superheroes!</p>
<doc-anchor-target id="managing-concurrency">
    <h4>
        <doc-anchor-trigger class="header-anchor-trigger" to="#managing-concurrency">#</doc-anchor-trigger>
        <span>Managing concurrency</span>
    </h4>
</doc-anchor-target>
<p>Let’s zoom back into the bustling city of Asyncville, where our superhero team, The Async Avengers, is facing its trickiest challenge yet: concurrency and synchronization!</p>
<p>In a world without synchronization, our heroes might accidentally bump into each other while racing to stop the villains. It’s like Super Speedster and Captain Code both tried to disarm the same bomb at the same time—kaboom! Confusion reigns, and the day is anything but saved.</p>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-csharp"><code v-pre class="language-csharp">int sharedResource = 0;

// Two heroes trying to update the same resource without synchronization.
Task hero1 = Task.Run(() =&gt; sharedResource++);
Task hero2 = Task.Run(() =&gt; sharedResource++);

await Task.WhenAll(hero1, hero2);
Console.WriteLine($&quot;Shared Resource Value (Chaos Ensues): {sharedResource}&quot;);</code></pre>
</doc-codeblock></div>
<p>In this chaotic scenario, our shared resource (like the city&#x27;s power grid) gets jumbled because our heroes didn&#x27;t coordinate their actions. They just charged in, so we don&#x27;t know if the grid is genuinely secure or how many times it&#x27;s been &quot;saved.&quot;</p>
<p>Now, let&#x27;s introduce some teamwork with synchronization. Imagine giving our heroes a plan, maybe a cosmic walkie-talkie, so they can communicate and take turns, ensuring no wires get crossed:</p>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-csharp"><code v-pre class="language-csharp">int sharedResource = 0;
object lockObject = new object();

// Heroes coordinating using a lock, like a relay race baton.
Task hero1 = Task.Run(() =&gt; { lock (lockObject) { sharedResource++; } });
Task hero2 = Task.Run(() =&gt; { lock (lockObject) { sharedResource++; } });

await Task.WhenAll(hero1, hero2);
Console.WriteLine($&quot;Shared Resource Value (Teamwork Triumphs): {sharedResource}&quot;);</code></pre>
</doc-codeblock></div>
<p>In this improved narrative, our Async Avengers use a magical lock (a synchronization tool), passing it like a baton to ensure only one hero updates the shared resource at a time. The result? A city is saved with precision and grace, with no overlapping efforts and no unintended side effects.</p>
<p>This, my fellow developers, is the power and beauty of mastering concurrency and synchronization in the world of C# async programming. By ensuring our code superheroes work together seamlessly, we prevent chaos and ensure that the digital realm remains a place of harmony and efficiency.</p>
<doc-anchor-target id="summary">
    <h2>
        <doc-anchor-trigger class="header-anchor-trigger" to="#summary">#</doc-anchor-trigger>
        <span>Summary</span>
    </h2>
</doc-anchor-target>
<p>Alright, let&#x27;s wrap up our epic saga in the bustling metropolis of Asyncville. Here, C# heroes flex their asynchronous muscles, especially when navigating the complex web of network programming.</p>
<p>In this city, our Async Avengers – from HttpClient Handler to FileStream Warrior – face off against the notorious villains of network latency and blocked UIs. These heroes, armed with the mighty powers of <code v-pre>async</code> and <code v-pre>await</code>, perform their daring deeds – fetching data, sending requests, and reading streams – all without freezing the city&#x27;s heartbeat, keeping the citizens (users) happy and oblivious to the chaos lurking in the shadows of the internet.</p>
<p>Our heroes&#x27; journey through the async landscape is peppered with challenges, from mastering the art of efficient resource use with <code v-pre>ConfigureAwait(false)</code> to coordinating their actions with the finesse of concurrency control and navigating the twisty paths of error handling without tripping over unexpected exceptions. They&#x27;ve learned the importance of a well-timed escape route, wielding cancellation tokens like an emergency exit in a villain&#x27;s lair, ensuring they can halt their operations immediately without leaving a mess behind.</p>
<p>But what makes our Async Avengers stand out is their ability to work silently in the background, tackling task after task without disturbing Main Thread City&#x27;s peaceful life. They are the unsung heroes of network programming, ensuring data flows like a steady stream, responses arrive just in time, and the digital universe remains a safe place for all.</p>

                                
                                <!-- Required only on API pages -->
                                <doc-toolbar-member-filter-no-results></doc-toolbar-member-filter-no-results>
                            </div>
                            <footer class="clear-both">
                                <div class="flex flex-wrap items-center justify-between mt-14">
                                    <a class="my-2.5 inline-flex items-center text-sm whitespace-nowrap text-blue-500 dark:text-blue-400 hover:text-blue-700 hover:underline" href="https://github.com/cwoodruff/book-network-programming-csharp/blob/main/Chapter04/chapter04.md" target="_blank" rel="noopener">
                                        <svg class="mr-1.5" xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="currentColor" overflow="visible"><path d="M20 12c-.55 0-1 .45-1 1v7c0 .55-.45 1-1 1H4c-.55 0-1-.45-1-1V6c0-.55.45-1 1-1h7c.55 0 1-.45 1-1s-.45-1-1-1H4C2.35 3 1 4.35 1 6v14c0 1.65 1.35 3 3 3h14c1.65 0 3-1.35 3-3v-7c0-.55-.45-1-1-1z" /><path d="M22.21 1.79c-1.18-1.18-3.24-1.18-4.41 0l-9.5 9.5c-.13.13-.22.29-.26.46l-1 4c-.08.34.01.7.26.95.18.2.44.3.7.3.08 0 .16-.01.24-.03l4-1c.18-.04.34-.13.46-.26l9.5-9.5c1.22-1.22 1.22-3.2.01-4.42zm-1.42 3l-9.3 9.3-2.11.53.53-2.11 9.3-9.3c.42-.42 1.16-.42 1.59 0 .43.43.43 1.15-.01 1.58z" /><path fill="none" d="M0 0h24v24H0z" /></svg>
                                        <span>Edit this page</span>
                                    </a>
                                </div>
                            
                            </footer>
                        </main>
                
                        <div class="border-t dark:border-dark-650 pt-6 mb-8">
                            <footer class="flex flex-wrap items-center justify-between">
                                <div>
                                    <ul class="flex flex-wrap items-center text-sm">
                                        <li>
                                            <a class="inline-flex items-center mr-4 py-2 text-sm whitespace-nowrap transition-colors duration-200 ease-linear text-blue-500 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-200 md:mb-0" href="../copyright/">
                                                <svg xmlns="http://www.w3.org/2000/svg" class="mb-px mr-1" width="18" height="18" viewBox="0 0 24 24" role="presentation">
                                                    <g fill="currentColor">
                                                        <path d="M10.97 8.265a1.45 1.45 0 0 0-.487.57.75.75 0 0 1-1.341-.67c.2-.402.513-.826.997-1.148C10.627 6.69 11.244 6.5 12 6.5c.658 0 1.369.195 1.934.619a2.45 2.45 0 0 1 1.004 2.006c0 1.033-.513 1.72-1.027 2.215-.19.183-.399.358-.579.508l-.147.123a4.329 4.329 0 0 0-.435.409v1.37a.75.75 0 1 1-1.5 0v-1.473c0-.237.067-.504.247-.736.22-.28.486-.517.718-.714l.183-.153.001-.001c.172-.143.324-.27.47-.412.368-.355.569-.676.569-1.136a.953.953 0 0 0-.404-.806C12.766 8.118 12.384 8 12 8c-.494 0-.814.121-1.03.265ZM13 17a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"/><path d="M12 1c6.075 0 11 4.925 11 11s-4.925 11-11 11S1 18.075 1 12 5.925 1 12 1ZM2.5 12a9.5 9.5 0 0 0 9.5 9.5 9.5 9.5 0 0 0 9.5-9.5A9.5 9.5 0 0 0 12 2.5 9.5 9.5 0 0 0 2.5 12Z"/>
                                                    </g>
                                                </svg>
                                                <span>Copyright</span>
                                            </a>
                                        </li>
                                        <li>
                                            <a class="inline-flex items-center mr-4 py-2 text-sm whitespace-nowrap transition-colors duration-200 ease-linear text-blue-500 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-200 md:mb-0" href="../license/">
                                                <svg xmlns="http://www.w3.org/2000/svg" class="mb-px mr-1" width="18" height="18" viewBox="0 0 24 24" role="presentation">
                                                    <g fill="currentColor">
                                                        <path d="M16.53 9.78a.75.75 0 0 0-1.06-1.06L11 13.19l-1.97-1.97a.75.75 0 0 0-1.06 1.06l2.5 2.5a.75.75 0 0 0 1.06 0l5-5Z"/><path d="m12.54.637 8.25 2.675A1.75 1.75 0 0 1 22 4.976V10c0 6.19-3.771 10.704-9.401 12.83a1.704 1.704 0 0 1-1.198 0C5.77 20.705 2 16.19 2 10V4.976c0-.758.489-1.43 1.21-1.664L11.46.637a1.748 1.748 0 0 1 1.08 0Zm-.617 1.426-8.25 2.676a.249.249 0 0 0-.173.237V10c0 5.46 3.28 9.483 8.43 11.426a.199.199 0 0 0 .14 0C17.22 19.483 20.5 15.461 20.5 10V4.976a.25.25 0 0 0-.173-.237l-8.25-2.676a.253.253 0 0 0-.154 0Z"/>
                                                    </g>
                                                </svg>
                                                <span>License</span>
                                            </a>
                                        </li>
                                    </ul>
                                </div>
                                <div class="docs-copyright py-2 text-gray-500 dark:text-dark-350 text-sm leading-relaxed"><p>© Copyright 2024. All rights reserved.</p></div>
                            </footer>
                        </div>
                    </div>
                
                    <!-- Rendered if sidebar right is enabled -->
                    <!-- Sidebar right skeleton-->
                    <div v-cloak class="fixed top-0 bottom-0 right-0 translate-x-full bg-white border-gray-200 lg:sticky lg:border-l lg:shrink-0 lg:pt-6 lg:transform-none sm:w-1/2 lg:w-64 lg:z-0 md:w-104 sidebar-right skeleton dark:bg-dark-850 dark:border-dark-650">
                        <div class="pl-5">
                            <div class="w-32 h-3 mb-4 bg-gray-200 dark:bg-dark-600 rounded-full loading"></div>
                            <div class="w-48 h-3 mb-4 bg-gray-200 dark:bg-dark-600 rounded-full loading"></div>
                            <div class="w-40 h-3 mb-4 bg-gray-200 dark:bg-dark-600 rounded-full loading"></div>
                        </div>
                    </div>
                
                    <!-- User should be able to hide sidebar right -->
                    <doc-sidebar-right v-cloak></doc-sidebar-right>
                </div>

            </div>
        </div>
    
        <doc-search-mobile></doc-search-mobile>
        <doc-back-to-top></doc-back-to-top>
    </div>


    <div id="docs-overlay-target"></div>

    <script data-cfasync="false">window.__DOCS__ = { "title": "Chap 4 - Asynchronous Programming with Async/Await", level: 1, icon: "file", hasPrism: true, hasMermaid: false, hasMath: false, tocDepth: 23 }</script>
</body>
</html>
