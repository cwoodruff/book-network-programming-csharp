<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-D5P830S5Z3"></script>
    <script data-cfasync="false">window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());gtag('config', 'G-D5P830S5Z3');</script>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="turbo-root" content="/book-network-programming-csharp">
    <meta name="turbo-cache-control" content="no-cache" data-turbo-track="reload" data-track-token="3.6.0.787665205012">

    <!-- See retype.com -->
    <meta name="generator" content="Retype 3.6.0">

    <!-- Primary Meta Tags -->
    <title>Asynchronous Programming with Async/Await</title>
    <meta name="title" content="Asynchronous Programming with Async/Await">
    <meta name="description" content="Welcome to a crucial chapter in your journey through Network Programming using C#, where we delve into Asynchronous programming using the ">

    <!-- Canonical -->
    <link rel="canonical" href="https://cwoodruff.github.io/book-network-programming-csharp/chapter04/">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://cwoodruff.github.io/book-network-programming-csharp/chapter04/">
    <meta property="og:title" content="Asynchronous Programming with Async/Await">
    <meta property="og:description" content="Welcome to a crucial chapter in your journey through Network Programming using C#, where we delve into Asynchronous programming using the ">
    <meta property="og:image" content="https://cwoodruff.github.io/book-network-programming-csharp/chapter04/images/chap04-asyncprogramming.png">

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://cwoodruff.github.io/book-network-programming-csharp/chapter04/">
    <meta property="twitter:title" content="Asynchronous Programming with Async/Await">
    <meta property="twitter:description" content="Welcome to a crucial chapter in your journey through Network Programming using C#, where we delve into Asynchronous programming using the ">
    <meta property="twitter:image" content="https://cwoodruff.github.io/book-network-programming-csharp/chapter04/images/chap04-asyncprogramming.png">

    <script data-cfasync="false">(function () { var el = document.documentElement, m = localStorage.getItem("doc_theme"), wm = window.matchMedia; if (m === "dark" || (!m && wm && wm("(prefers-color-scheme: dark)").matches)) { el.classList.add("dark") } else { el.classList.remove("dark") } })();</script>

    <link href="../images/favicon.png" rel="icon">
    <link href="../resources/css/retype.css?v=3.6.0.787665205012" rel="stylesheet">

    <script data-cfasync="false" src="../resources/js/config.js?v=3.6.0.787665205012" data-turbo-eval="false" defer></script>
    <script data-cfasync="false" src="../resources/js/retype.js?v=3.6.0" data-turbo-eval="false" defer></script>
    <script id="lunr-js" data-cfasync="false" src="../resources/js/lunr.js?v=3.6.0.787665205012" data-turbo-eval="false" defer></script>
    <script id="prism-js" data-cfasync="false" src="../resources/js/prism.js?v=3.6.0.787665205012" defer></script>
</head>
<body>
    <div id="docs-app" class="relative text-base antialiased text-gray-700 bg-white font-body dark:bg-dark-850 dark:text-dark-300">
        <div class="absolute bottom-0 left-0 bg-gray-100 dark:bg-dark-800" style="top: 5rem; right: 50%"></div>
    
        <header id="docs-site-header" class="sticky top-0 z-30 flex w-full h-16 bg-white border-b border-gray-200 md:h-20 dark:bg-dark-850 dark:border-dark-650">
            <div class="container relative flex items-center justify-between pr-6 grow md:justify-start">
                <!-- Mobile menu button skeleton -->
                <button v-cloak class="skeleton docs-mobile-menu-button flex items-center justify-center shrink-0 overflow-hidden dark:text-white focus:outline-none rounded-full w-10 h-10 ml-3.5 md:hidden"><svg xmlns="http://www.w3.org/2000/svg" class="mb-px shrink-0" width="24" height="24" viewBox="0 0 24 24" role="presentation" style="margin-bottom: 0px;"><g fill="currentColor"><path d="M2 4h20v2H2zM2 11h20v2H2zM2 18h20v2H2z"></path></g></svg></button>
                <div v-cloak id="docs-sidebar-toggle"></div>
        
                <!-- Logo -->
                <div class="flex items-center justify-between h-full py-2 md:w-75">
                    <div class="flex items-center px-2 md:px-6">
                        <a id="docs-site-logo" href="../" class="flex items-center leading-snug text-xl">
                            <span class="w-10 mr-2 grow-0 shrink-0 overflow-hidden">
                                <img class="max-h-10 dark:hidden md:inline-block" src="../images/network200.png">
                                <img class="max-h-10 hidden dark:inline-block" src="../images/network200.png">
                            </span>
                            <span class="dark:text-white font-semibold line-clamp-1 md:line-clamp-2">Networking Programming with C/# 12 and /.NET 8</span>
                        </a><span class="hidden px-2 py-1 ml-4 text-sm font-semibold leading-none text-root-logo-label-text bg-root-logo-label-bg rounded-sm md:inline-block">v1</span>
                    </div>
        
                    <span class="hidden h-8 border-r md:inline-block dark:border-dark-650"></span>
                </div>
        
                <div class="flex justify-between md:grow">
                    <!-- Top Nav -->
                    <nav class="hidden md:flex">
                        <ul class="flex flex-col mb-4 md:pl-16 md:mb-0 md:flex-row md:items-center">
                            <li class="mr-6">
                                <a class="py-2 md:mb-0 inline-flex items-center text-sm whitespace-nowrap transition-colors duration-200 ease-linear md:text-blue-500 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-200" href="../">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="mb-px mr-1" width="18" height="18" viewBox="0 0 24 24" role="presentation">
                                        <g fill="currentColor">
                                            <path d="M11.03 2.59a1.501 1.501 0 0 1 1.94 0l7.5 6.363a1.5 1.5 0 0 1 .53 1.144V19.5a1.5 1.5 0 0 1-1.5 1.5h-5.75a.75.75 0 0 1-.75-.75V14h-2v6.25a.75.75 0 0 1-.75.75H4.5A1.5 1.5 0 0 1 3 19.5v-9.403c0-.44.194-.859.53-1.144ZM12 3.734l-7.5 6.363V19.5h5v-6.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v6.25h5v-9.403Z"/>
                                        </g>
                                    </svg>
                                    <span>Home</span>
                                </a>
                            </li>
                            <li class="mr-6">
                                <a class="py-2 md:mb-0 inline-flex items-center text-sm whitespace-nowrap transition-colors duration-200 ease-linear md:text-blue-500 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-200" href="https://github.com/cwoodruff/book-network-programming-csharp/issues" target="_blank">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="mb-px mr-1" width="18" height="18" viewBox="0 0 24 24" role="presentation">
                                        <g fill="currentColor">
                                            <path d="M1.75 1h12.5c.966 0 1.75.784 1.75 1.75v9.5A1.75 1.75 0 0 1 14.25 14H8.061l-2.574 2.573A1.458 1.458 0 0 1 3 15.543V14H1.75A1.75 1.75 0 0 1 0 12.25v-9.5C0 1.784.784 1 1.75 1ZM1.5 2.75v9.5c0 .138.112.25.25.25h2a.75.75 0 0 1 .75.75v2.19l2.72-2.72a.749.749 0 0 1 .53-.22h6.5a.25.25 0 0 0 .25-.25v-9.5a.25.25 0 0 0-.25-.25H1.75a.25.25 0 0 0-.25.25Z"/><path d="M22.5 8.75a.25.25 0 0 0-.25-.25h-3.5a.75.75 0 0 1 0-1.5h3.5c.966 0 1.75.784 1.75 1.75v9.5A1.75 1.75 0 0 1 22.25 20H21v1.543a1.457 1.457 0 0 1-2.487 1.03L15.939 20H10.75A1.75 1.75 0 0 1 9 18.25v-1.465a.75.75 0 0 1 1.5 0v1.465c0 .138.112.25.25.25h5.5a.75.75 0 0 1 .53.22l2.72 2.72v-2.19a.75.75 0 0 1 .75-.75h2a.25.25 0 0 0 .25-.25v-9.5Z"/>
                                        </g>
                                    </svg>
                                    <span>Issues</span>
                                </a>
                            </li>
                            <li class="mr-6">
                                <a class="py-2 md:mb-0 inline-flex items-center text-sm whitespace-nowrap transition-colors duration-200 ease-linear md:text-blue-500 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-200" href="https://twitter.com/cwoodruff/" target="_blank">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="mb-px mr-1" width="18" height="18" viewBox="0 0 24 24" role="presentation">
                                        <g fill="currentColor">
                                            <path d="M19 0h-14c-2.761 0-5 2.239-5 5v14c0 2.761 2.239 5 5 5h14c2.762 0 5-2.239 5-5v-14c0-2.761-2.238-5-5-5zm-.139 9.237c.209 4.617-3.234 9.765-9.33 9.765-1.854 0-3.579-.543-5.032-1.475 1.742.205 3.48-.278 4.86-1.359-1.437-.027-2.649-.976-3.066-2.28.515.098 1.021.069 1.482-.056-1.579-.317-2.668-1.739-2.633-3.26.442.246.949.394 1.486.411-1.461-.977-1.875-2.907-1.016-4.383 1.619 1.986 4.038 3.293 6.766 3.43-.479-2.053 1.08-4.03 3.199-4.03.943 0 1.797.398 2.395 1.037.748-.147 1.451-.42 2.086-.796-.246.767-.766 1.41-1.443 1.816.664-.08 1.297-.256 1.885-.517-.439.656-.996 1.234-1.639 1.697z"/>
                                        </g>
                                    </svg>
                                    <span>Twitter</span>
                                </a>
                            </li>
        
                        </ul>
                    </nav>
        
                    <!-- Header Right Skeleton -->
                    <div v-cloak class="flex justify-end grow skeleton">
        
                        <!-- Search input mock -->
                        <div class="relative hidden w-40 lg:block lg:max-w-sm lg:ml-auto">
                            <div class="absolute flex items-center justify-center h-full pl-3 dark:text-dark-300">
                                <svg xmlns="http://www.w3.org/2000/svg" class="icon-base" width="16" height="16" viewBox="0 0 24 24" aria-labelledby="icon" role="presentation" style="margin-bottom: 1px;"><g fill="currentColor" ><path d="M21.71 20.29l-3.68-3.68A8.963 8.963 0 0020 11c0-4.96-4.04-9-9-9s-9 4.04-9 9 4.04 9 9 9c2.12 0 4.07-.74 5.61-1.97l3.68 3.68c.2.19.45.29.71.29s.51-.1.71-.29c.39-.39.39-1.03 0-1.42zM4 11c0-3.86 3.14-7 7-7s7 3.14 7 7c0 1.92-.78 3.66-2.04 4.93-.01.01-.02.01-.02.01-.01.01-.01.01-.01.02A6.98 6.98 0 0111 18c-3.86 0-7-3.14-7-7z" ></path></g></svg>
                            </div>
                            <input class="w-full h-10 placeholder-gray-400 transition-colors duration-200 ease-in bg-gray-200 border border-transparent rounded md:text-sm hover:bg-white hover:border-gray-300 focus:outline-none focus:bg-white focus:border-gray-500 dark:bg-dark-600 dark:border-dark-600 dark:placeholder-dark-400" style="padding: 0.625rem 0.75rem 0.625rem 2rem" type="text" placeholder="Search">
                        </div>
        
                        <!-- Mobile search button -->
                        <div class="flex items-center justify-center w-10 h-10 lg:hidden">
                            <svg xmlns="http://www.w3.org/2000/svg" class="shrink-0 icon-base" width="20" height="20" viewBox="0 0 24 24" aria-labelledby="icon" role="presentation" style="margin-bottom: 0px;"><g fill="currentColor" ><path d="M21.71 20.29l-3.68-3.68A8.963 8.963 0 0020 11c0-4.96-4.04-9-9-9s-9 4.04-9 9 4.04 9 9 9c2.12 0 4.07-.74 5.61-1.97l3.68 3.68c.2.19.45.29.71.29s.51-.1.71-.29c.39-.39.39-1.03 0-1.42zM4 11c0-3.86 3.14-7 7-7s7 3.14 7 7c0 1.92-.78 3.66-2.04 4.93-.01.01-.02.01-.02.01-.01.01-.01.01-.01.02A6.98 6.98 0 0111 18c-3.86 0-7-3.14-7-7z" ></path></g></svg>
                        </div>
        
                        <!-- Dark mode switch placeholder -->
                        <div class="w-10 h-10 lg:ml-2"></div>
        
                        <!-- History button -->
                        <div class="flex items-center justify-center w-10 h-10" style="margin-right: -0.625rem;">
                            <svg xmlns="http://www.w3.org/2000/svg" class="shrink-0 icon-base" width="22" height="22" viewBox="0 0 24 24" aria-labelledby="icon" role="presentation" style="margin-bottom: 0px;"><g fill="currentColor" ><g ><path d="M12.01 6.01c-.55 0-1 .45-1 1V12a1 1 0 00.4.8l3 2.22a.985.985 0 001.39-.2.996.996 0 00-.21-1.4l-2.6-1.92V7.01c.02-.55-.43-1-.98-1z"></path><path d="M12.01 1.91c-5.33 0-9.69 4.16-10.05 9.4l-.29-.26a.997.997 0 10-1.34 1.48l1.97 1.79c.19.17.43.26.67.26s.48-.09.67-.26l1.97-1.79a.997.997 0 10-1.34-1.48l-.31.28c.34-4.14 3.82-7.41 8.05-7.41 4.46 0 8.08 3.63 8.08 8.09s-3.63 8.08-8.08 8.08c-2.18 0-4.22-.85-5.75-2.4a.996.996 0 10-1.42 1.4 10.02 10.02 0 007.17 2.99c5.56 0 10.08-4.52 10.08-10.08.01-5.56-4.52-10.09-10.08-10.09z"></path></g></g></svg>
                        </div>
                    </div>
        
                    <div v-cloak class="flex justify-end grow">
                        <div id="docs-mobile-search-button"></div>
                        <doc-search-desktop></doc-search-desktop>
        
                        <doc-theme-switch class="lg:ml-2"></doc-theme-switch>
                        <doc-history></doc-history>
                    </div>
                </div>
            </div>
        </header>
    
        <div class="container relative flex bg-white">
            <!-- Sidebar Skeleton -->
            <div v-cloak class="fixed flex flex-col shrink-0 duration-300 ease-in-out bg-gray-100 border-gray-200 sidebar top-20 w-75 border-r h-screen md:sticky transition-transform skeleton dark:bg-dark-800 dark:border-dark-650">
            
                <!-- Render this div, if config.showSidebarFilter is `true` -->
                <div class="flex items-center h-16 px-6">
                    <input class="w-full h-8 px-3 py-2 transition-colors duration-200 ease-linear bg-white border border-gray-200 rounded shadow-none text-sm focus:outline-none focus:border-gray-600 dark:bg-dark-600 dark:border-dark-600" type="text" placeholder="Filter">
                </div>
            
                <div class="pl-6 mt-1 mb-4">
                    <div class="w-32 h-3 mb-4 bg-gray-200 rounded-full loading dark:bg-dark-600"></div>
                    <div class="w-48 h-3 mb-4 bg-gray-200 rounded-full loading dark:bg-dark-600"></div>
                    <div class="w-40 h-3 mb-4 bg-gray-200 rounded-full loading dark:bg-dark-600"></div>
                    <div class="w-32 h-3 mb-4 bg-gray-200 rounded-full loading dark:bg-dark-600"></div>
                    <div class="w-48 h-3 mb-4 bg-gray-200 rounded-full loading dark:bg-dark-600"></div>
                    <div class="w-40 h-3 mb-4 bg-gray-200 rounded-full loading dark:bg-dark-600"></div>
                </div>
            
                <div class="shrink-0 mt-auto bg-transparent dark:border-dark-650">
                    <a class="flex items-center justify-center flex-nowrap h-16 text-gray-400 dark:text-dark-400 hover:text-gray-700 dark:hover:text-dark-300 transition-colors duration-150 ease-in docs-powered-by" target="_blank" href="https://retype.com/" rel="noopener">
                        <span class="text-xs whitespace-nowrap">Powered by</span>
                        <svg xmlns="http://www.w3.org/2000/svg" class="ml-2" fill="currentColor" width="96" height="20" overflow="visible"><path d="M0 0v20h13.59V0H0zm11.15 17.54H2.44V2.46h8.71v15.08zM15.8 20h2.44V4.67L15.8 2.22zM20.45 6.89V20h2.44V9.34z"/><g><path d="M40.16 8.44c0 1.49-.59 2.45-1.75 2.88l2.34 3.32h-2.53l-2.04-2.96h-1.43v2.96h-2.06V5.36h3.5c1.43 0 2.46.24 3.07.73s.9 1.27.9 2.35zm-2.48 1.1c.26-.23.38-.59.38-1.09 0-.5-.13-.84-.4-1.03s-.73-.28-1.39-.28h-1.54v2.75h1.5c.72 0 1.2-.12 1.45-.35zM51.56 5.36V7.2h-4.59v1.91h4.13v1.76h-4.13v1.92h4.74v1.83h-6.79V5.36h6.64zM60.09 7.15v7.48h-2.06V7.15h-2.61V5.36h7.28v1.79h-2.61zM70.81 14.64h-2.06v-3.66l-3.19-5.61h2.23l1.99 3.45 1.99-3.45H74l-3.19 5.61v3.66zM83.99 6.19c.65.55.97 1.4.97 2.55s-.33 1.98-1 2.51-1.68.8-3.04.8h-1.23v2.59h-2.06V5.36h3.26c1.42 0 2.45.28 3.1.83zm-1.51 3.65c.25-.28.37-.69.37-1.22s-.16-.92-.48-1.14c-.32-.23-.82-.34-1.5-.34H79.7v3.12h1.38c.68 0 1.15-.14 1.4-.42zM95.85 5.36V7.2h-4.59v1.91h4.13v1.76h-4.13v1.92H96v1.83h-6.79V5.36h6.64z"/></g></svg>
                    </a>
                </div>
            </div>
            
            <!-- Sidebar component -->
            <doc-sidebar v-cloak>
                <template #sidebar-footer>
                    <div class="shrink-0 mt-auto border-t md:bg-transparent md:border-none dark:border-dark-650">
            
                        <div class="py-3 px-6 md:hidden border-b dark:border-dark-650">
                            <nav>
                                <ul class="flex flex-wrap justify-center items-center">
                                    <li class="mr-6">
                                        <a class="block py-1 inline-flex items-center text-sm whitespace-nowrap transition-colors duration-200 ease-linear md:text-blue-500 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-200" href="../">
                                            <svg xmlns="http://www.w3.org/2000/svg" class="mb-px mr-1" width="18" height="18" viewBox="0 0 24 24" role="presentation">
                                                <g fill="currentColor">
                                                    <path d="M11.03 2.59a1.501 1.501 0 0 1 1.94 0l7.5 6.363a1.5 1.5 0 0 1 .53 1.144V19.5a1.5 1.5 0 0 1-1.5 1.5h-5.75a.75.75 0 0 1-.75-.75V14h-2v6.25a.75.75 0 0 1-.75.75H4.5A1.5 1.5 0 0 1 3 19.5v-9.403c0-.44.194-.859.53-1.144ZM12 3.734l-7.5 6.363V19.5h5v-6.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v6.25h5v-9.403Z"/>
                                                </g>
                                            </svg>
                                            <span>Home</span>
                                        </a>
                                    </li>
                                    <li class="mr-6">
                                        <a class="block py-1 inline-flex items-center text-sm whitespace-nowrap transition-colors duration-200 ease-linear md:text-blue-500 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-200" href="https://github.com/cwoodruff/book-network-programming-csharp/issues" target="_blank">
                                            <svg xmlns="http://www.w3.org/2000/svg" class="mb-px mr-1" width="18" height="18" viewBox="0 0 24 24" role="presentation">
                                                <g fill="currentColor">
                                                    <path d="M1.75 1h12.5c.966 0 1.75.784 1.75 1.75v9.5A1.75 1.75 0 0 1 14.25 14H8.061l-2.574 2.573A1.458 1.458 0 0 1 3 15.543V14H1.75A1.75 1.75 0 0 1 0 12.25v-9.5C0 1.784.784 1 1.75 1ZM1.5 2.75v9.5c0 .138.112.25.25.25h2a.75.75 0 0 1 .75.75v2.19l2.72-2.72a.749.749 0 0 1 .53-.22h6.5a.25.25 0 0 0 .25-.25v-9.5a.25.25 0 0 0-.25-.25H1.75a.25.25 0 0 0-.25.25Z"/><path d="M22.5 8.75a.25.25 0 0 0-.25-.25h-3.5a.75.75 0 0 1 0-1.5h3.5c.966 0 1.75.784 1.75 1.75v9.5A1.75 1.75 0 0 1 22.25 20H21v1.543a1.457 1.457 0 0 1-2.487 1.03L15.939 20H10.75A1.75 1.75 0 0 1 9 18.25v-1.465a.75.75 0 0 1 1.5 0v1.465c0 .138.112.25.25.25h5.5a.75.75 0 0 1 .53.22l2.72 2.72v-2.19a.75.75 0 0 1 .75-.75h2a.25.25 0 0 0 .25-.25v-9.5Z"/>
                                                </g>
                                            </svg>
                                            <span>Issues</span>
                                        </a>
                                    </li>
                                    <li class="mr-6">
                                        <a class="block py-1 inline-flex items-center text-sm whitespace-nowrap transition-colors duration-200 ease-linear md:text-blue-500 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-200" href="https://twitter.com/cwoodruff/" target="_blank">
                                            <svg xmlns="http://www.w3.org/2000/svg" class="mb-px mr-1" width="18" height="18" viewBox="0 0 24 24" role="presentation">
                                                <g fill="currentColor">
                                                    <path d="M19 0h-14c-2.761 0-5 2.239-5 5v14c0 2.761 2.239 5 5 5h14c2.762 0 5-2.239 5-5v-14c0-2.761-2.238-5-5-5zm-.139 9.237c.209 4.617-3.234 9.765-9.33 9.765-1.854 0-3.579-.543-5.032-1.475 1.742.205 3.48-.278 4.86-1.359-1.437-.027-2.649-.976-3.066-2.28.515.098 1.021.069 1.482-.056-1.579-.317-2.668-1.739-2.633-3.26.442.246.949.394 1.486.411-1.461-.977-1.875-2.907-1.016-4.383 1.619 1.986 4.038 3.293 6.766 3.43-.479-2.053 1.08-4.03 3.199-4.03.943 0 1.797.398 2.395 1.037.748-.147 1.451-.42 2.086-.796-.246.767-.766 1.41-1.443 1.816.664-.08 1.297-.256 1.885-.517-.439.656-.996 1.234-1.639 1.697z"/>
                                                </g>
                                            </svg>
                                            <span>Twitter</span>
                                        </a>
                                    </li>
            
                                </ul>
                            </nav>
                        </div>
            
                        <a class="flex items-center justify-center flex-nowrap h-16 text-gray-400 dark:text-dark-400 hover:text-gray-700 dark:hover:text-dark-300 transition-colors duration-150 ease-in docs-powered-by" target="_blank" href="https://retype.com/" rel="noopener">
                            <span class="text-xs whitespace-nowrap">Powered by</span>
                            <svg xmlns="http://www.w3.org/2000/svg" class="ml-2" fill="currentColor" width="96" height="20" overflow="visible"><path d="M0 0v20h13.59V0H0zm11.15 17.54H2.44V2.46h8.71v15.08zM15.8 20h2.44V4.67L15.8 2.22zM20.45 6.89V20h2.44V9.34z"/><g><path d="M40.16 8.44c0 1.49-.59 2.45-1.75 2.88l2.34 3.32h-2.53l-2.04-2.96h-1.43v2.96h-2.06V5.36h3.5c1.43 0 2.46.24 3.07.73s.9 1.27.9 2.35zm-2.48 1.1c.26-.23.38-.59.38-1.09 0-.5-.13-.84-.4-1.03s-.73-.28-1.39-.28h-1.54v2.75h1.5c.72 0 1.2-.12 1.45-.35zM51.56 5.36V7.2h-4.59v1.91h4.13v1.76h-4.13v1.92h4.74v1.83h-6.79V5.36h6.64zM60.09 7.15v7.48h-2.06V7.15h-2.61V5.36h7.28v1.79h-2.61zM70.81 14.64h-2.06v-3.66l-3.19-5.61h2.23l1.99 3.45 1.99-3.45H74l-3.19 5.61v3.66zM83.99 6.19c.65.55.97 1.4.97 2.55s-.33 1.98-1 2.51-1.68.8-3.04.8h-1.23v2.59h-2.06V5.36h3.26c1.42 0 2.45.28 3.1.83zm-1.51 3.65c.25-.28.37-.69.37-1.22s-.16-.92-.48-1.14c-.32-.23-.82-.34-1.5-.34H79.7v3.12h1.38c.68 0 1.15-.14 1.4-.42zM95.85 5.36V7.2h-4.59v1.91h4.13v1.76h-4.13v1.92H96v1.83h-6.79V5.36h6.64z"/></g></svg>
                        </a>
                    </div>
                </template>
            </doc-sidebar>
    
            <div class="grow min-w-0 dark:bg-dark-850">
                <!-- Render "toolbar" template here on api pages --><!-- Render page content -->
                <div class="flex">
                    <div class="min-w-0 p-4 grow md:px-16">
                        <main class="relative pb-12 lg:pt-2">
                            <div class="docs-markdown" id="docs-content">
                                <!-- Rendered if sidebar right is enabled -->
                                <div id="docs-sidebar-right-toggle"></div>
                                <!-- Page content  -->
<doc-anchor-target id="asynchronous-programming-with-asyncawait" class="break-words">
    <h1>
        <doc-anchor-trigger class="header-anchor-trigger" to="#asynchronous-programming-with-asyncawait">#</doc-anchor-trigger>
        <span>Asynchronous Programming with Async/Await</span>
    </h1>
</doc-anchor-target>
<p><figure class="content-center">
    <img src="images/chap04-asyncprogramming.png" alt="">
    <figcaption class="caption"></figcaption>
</figure>
</p>
<doc-anchor-target id="4" class="break-words">
    <h1>
        <doc-anchor-trigger class="header-anchor-trigger" to="#4">#</doc-anchor-trigger>
        <span>4</span>
    </h1>
</doc-anchor-target>
<doc-anchor-target id="asynchronous-programming-with-asyncawait">
    <h1>
        <doc-anchor-trigger class="header-anchor-trigger" to="#asynchronous-programming-with-asyncawait">#</doc-anchor-trigger>
        <span>Asynchronous Programming with Async/Await</span>
    </h1>
</doc-anchor-target>
<p>Welcome to a crucial chapter in your journey through Network Programming using C#, where we delve into Asynchronous programming using the <code v-pre>async</code> and <code v-pre>await</code> keywords. As you have been threading your way through the intricacies of network programming, you&#x27;ve learned how to create robust connections, transmit data, and handle various network protocols. Now, we have reached a point where efficiency and responsiveness become paramount. In this chapter, we will explore the power and elegance of C#&#x27;s asynchronous programming paradigms that enhance performance and maintain the responsiveness of applications, even when faced with the most demanding network operations.</p>
<p>By their nature, network applications deal with inherently time-consuming and unpredictable operations. The data may travel across continents, and the time it takes to send a request and receive a response can be significant, which in turn may mean your application is spending precious CPU cycles doing nothing but waiting for data to be moved around over the network. This is where asynchronous programming shines. With the <code v-pre>async</code> and <code v-pre>await</code> keywords introduced in C# 5.0, we&#x27;re equipped to write both efficiently and easily read, resembling the straightforwardness of synchronous code while executing non-blocking.</p>
<p>Imagine a scenario where your application must fetch large amounts of data from a remote server or wait for a file to download over a slow connection. Blocking the user interface or consuming thread resources unnecessarily while these operations complete would lead to a subpar user experience and inefficient resource utilization. Through practical examples, we will demonstrate how asynchronous methods allow your application to remain responsive to user interactions by freeing up threads to handle other tasks while waiting for the network operations to complete.</p>
<p>By the end of this chapter, you&#x27;ll understand how to use <code v-pre>async</code> and <code v-pre>await</code> to perform network operations without the complexity traditionally associated with asynchronous programming. You&#x27;ll be able to write code that&#x27;s not only more performant but also simpler and more maintainable. You will learn how to handle exceptions in asynchronous code, report progress, and cancel long-running network operations gracefully.</p>
<p>In this chapter, we are going to cover the following main topics:</p>
<ul>
<li>Introduction to Asynchronous Programming</li>
<li>Understanding Async/Await and Asynchronous Operations</li>
<li>Strategies for Writing Asynchronous Code</li>
</ul>
<doc-anchor-target id="introducing-asynchronous-programming">
    <h2>
        <doc-anchor-trigger class="header-anchor-trigger" to="#introducing-asynchronous-programming">#</doc-anchor-trigger>
        <span>Introducing asynchronous programming</span>
    </h2>
</doc-anchor-target>
<p>Understanding asynchronous programming is paramount in the context of .NET and C# network programming. Asynchronous programming allows a program to handle multiple tasks simultaneously, which is particularly beneficial in network operations where I/O-bound work, such as web requests, file reading, or database operations, can lead to significant idle time. In traditional synchronous execution, a thread would block or wait for the operation to complete before moving on to the next task, leading to inefficient use of resources and a sluggish user experience. Asynchronous programming, on the other hand, enables the execution thread to perform other tasks while waiting for the network operation to complete, thus making better use of system resources and improving application responsiveness.</p>
<p>In C#, asynchronous programming is primarily achieved using the async and await keywords, which are elegantly integrated into the language and runtime environment. When a method is marked with the <code v-pre>async</code> keyword, it contains asynchronous operations and returns a <code v-pre>Task</code> or <code v-pre>Task&lt;T&gt;</code>. The <code v-pre>await</code> keyword is then used to call these asynchronous methods, allowing the current method to pause its execution until the awaited task completes without blocking the thread. Compared to older asynchronous programming patterns, this model simplifies error handling, exception propagation, and synchronization context management. As a result, developers can write more readable and maintainable code, which is crucial for complex network programming tasks in .NET environments.</p>
<doc-anchor-target id="historical-context">
    <h3>
        <doc-anchor-trigger class="header-anchor-trigger" to="#historical-context">#</doc-anchor-trigger>
        <span>Historical context</span>
    </h3>
</doc-anchor-target>
<p>Asynchronous programming has evolved significantly since its inception. Initially, C# and the .NET provided essential support for asynchronous operations through mechanisms such as the <code v-pre>IAsyncResult</code> pattern and the <code v-pre>BeginInvoke</code> and <code v-pre>EndInvoke</code> methods. These early approaches were practical but often led to complex and hard-to-read code, especially when dealing with nested or multiple asynchronous operations. The code was cluttered with callbacks and manual thread management, making it cumbersome to write and maintain.</p>
<p>With the release of C# 5.0 and .NET Framework 4.5, the landscape of asynchronous programming underwent a substantial transformation by introducing the <code v-pre>async</code> and <code v-pre>await</code> keywords. This new model significantly simplified the writing and understanding of asynchronous code, allowing developers to write asynchronous operations in a manner that closely resembles synchronous code, thereby reducing the complexity and improving readability. This approach abstracted much of the boilerplate code associated with earlier patterns and allowed the compiler to handle the intricacies of thread management and callback handling. Since then, asynchronous programming has become an integral part of C#, continually enhanced with new features and improvements in subsequent versions of the language and the .NET, making it an essential tool for modern software development, particularly in areas requiring extensive I/O operations like network programming.</p>
<doc-anchor-target id="the-role-of-asynchronous-programming-in-network-applications">
    <h3>
        <doc-anchor-trigger class="header-anchor-trigger" to="#the-role-of-asynchronous-programming-in-network-applications">#</doc-anchor-trigger>
        <span>The role of asynchronous programming in network applications</span>
    </h3>
</doc-anchor-target>
<p>Asynchronous programming plays a critical role in the development and performance of network applications. In networking, where applications frequently wait for data to be sent or received across the internet or other networks, the efficiency of handling these I/O operations can significantly impact the overall performance and user experience. By implementing asynchronous programming, developers can ensure that an application remains responsive and efficient, even when dealing with slow network connections or large data transfers.</p>
<p>The role of asynchronous programming in network applications is particularly evident in scenarios involving high levels of network traffic and data processing. Instead of halting execution until a network response is received (as seen in synchronous operations), an asynchronous approach allows the application to continue processing other tasks, such as user input or computational operations while waiting for the network response. This non-blocking behavior is essential for creating smooth and responsive user interfaces, especially in web applications, mobile apps, and cloud-based services where users expect real-time interactions and performance.</p>
<p>Furthermore, asynchronous programming enables better resource utilization and scalability in network applications. By freeing up threads that would otherwise be idle during blocking I/O operations, these threads can be used for other purposes, increasing the overall throughput of the application. This is particularly important in server-side applications, where efficiently handling multiple concurrent requests can significantly impact the service&#x27;s scalability and reliability. As such, asynchronous programming is not just a feature of modern network applications but a fundamental aspect that drives their performance, scalability, and user satisfaction.</p>
<doc-anchor-target id="challenges-of-asynchronous-programming">
    <h3>
        <doc-anchor-trigger class="header-anchor-trigger" to="#challenges-of-asynchronous-programming">#</doc-anchor-trigger>
        <span>Challenges of asynchronous programming</span>
    </h3>
</doc-anchor-target>
<p>Asynchronous programming has been a game-changer for developing responsive applications, allowing operations to run concurrently without blocking the main thread. This paradigm, enabled by the use of async and await keywords, is essential for performing time-consuming tasks such as file IO, database operations, and web requests in a way that keeps user interfaces snappy and responsive. However, despite its advantages, asynchronous programming introduces several challenges that complicate development and debugging.</p>
<p>Managing complex control flows is a significant challenge of asynchronous programming. As applications become complex, so does the web of asynchronous operations, making it harder to follow the execution flow. This complexity can lead to issues such as race conditions, where the timing and order of execution affect the program&#x27;s outcome, and deadlocks, particularly in UI applications where the main thread waits on an asynchronous operation that, in turn, waits on the main thread. Moreover, exceptions thrown in asynchronous tasks must be carefully handled; otherwise, they can lead to unobserved task exceptions that crash the application.</p>
<p>Debugging asynchronous code poses another significant challenge. Traditional debugging techniques are less effective because breakpoints in asynchronous code do not always follow the intuitive execution path, significantly when tasks are awaited or run in parallel. Visual Studio provides tools and windows to aid in debugging asynchronous code, such as Tasks, Parallel Stacks, and Parallel Watch windows, but developers need to adapt their debugging strategies. Additionally, understanding and optimizing the performance of asynchronous applications can be difficult. If not managed carefully, the overhead of task scheduling and context switching can negate the benefits of asynchronous operations, leading to inefficient resource use and poorer performance than synchronous counterparts under certain conditions. Despite these challenges, mastering asynchronous programming in C# is essential for building modern, responsive applications, and with practice and the right tools, developers can navigate these complexities effectively.</p>
<doc-anchor-target id="common-pitfalls">
    <h3>
        <doc-anchor-trigger class="header-anchor-trigger" to="#common-pitfalls">#</doc-anchor-trigger>
        <span>Common pitfalls</span>
    </h3>
</doc-anchor-target>
<p>When developing network solutions, developers often encounter several common pitfalls and issues with asynchronous programming, which can impact their applications&#x27; performance, reliability, and maintainability.</p>
<p>One of the most common pitfalls is misusing async and await, particularly misunderstanding where and when to apply them. Some developers might apply the async keyword to every method, leading to unnecessary overhead or misuse of the await keyword, resulting in deadlocks or inefficient resource use. For example, improperly using await within a loop can inadvertently turn asynchronous code into synchronous, blocking code, negating the benefits of asynchronous programming and leading to performance bottlenecks.</p>
<p>Another significant issue is exception handling in asynchronous code. If not correctly awaited or handled, exceptions thrown in asynchronous tasks are not always caught in the traditional try-catch blocks, leading to unobserved exceptions that can cause unexpected behavior or application crashes. Developers must ensure that all asynchronous operations are properly awaited and any exceptions are caught and handled appropriately to maintain application stability.</p>
<p>Resource management presents another challenge in asynchronous network programming. Asynchronous operations can lead to more concurrent operations, increasing the load on system resources such as network connections or memory. If not carefully managed, this can result in resource leaks, where resources are not properly released, or resource contention, where too many operations compete for limited resources. Both can degrade application performance and lead to failures.</p>
<p>Additionally, developers may need help maintaining code clarity and readability when using asynchronous programming, especially when dealing with nested asynchronous calls or complex control flow. This can make the code harder to understand, debug, and maintain, especially for those new to asynchronous programming or working on a large, complex codebase.</p>
<doc-anchor-target id="understanding-the-synchronization-context">
    <h3>
        <doc-anchor-trigger class="header-anchor-trigger" to="#understanding-the-synchronization-context">#</doc-anchor-trigger>
        <span>Understanding the synchronization context</span>
    </h3>
</doc-anchor-target>
<p>In C# network projects, understanding the synchronization context is crucial for effectively managing the concurrency of asynchronous operations. The synchronization context in .NET allows the queue of work items, messages, or event handlers to return to the original context or thread, such as the UI thread in a Windows Forms or WPF application. This is particularly important in network applications where UI updates or resource access must be synchronized with network responses to avoid race conditions, deadlocks, or updating the UI from a non-UI thread, which can cause exceptions. Developers should grasp how the synchronization context is captured and used by the async and await keywords to marshal the execution of continuations (the code that runs after an await operation) back to the original context, ensuring that UI updates are safe and that resources are accessed correctly.</p>
<p>However, over-reliance on the synchronization context, especially in server-side network applications like ASP.NET, can lead to performance bottlenecks and scalability issues. In such environments, it&#x27;s often beneficial to avoid capturing the synchronization context for asynchronous operations without updating the UI or accessing thread-specific resources. Developers should understand when to use ConfigureAwait(false) in their awaitable calls. This tells the runtime not to capture and marshal the continuation back to the original synchronization context, thus improving efficiency and reducing the likelihood of deadlocks. Understanding and managing the synchronization context appropriately allows developers to write more efficient, scalable, and maintainable asynchronous C# network applications.</p>
<doc-anchor-target id="understanding-asyncawait-and-asynchronous-operations">
    <h2>
        <doc-anchor-trigger class="header-anchor-trigger" to="#understanding-asyncawait-and-asynchronous-operations">#</doc-anchor-trigger>
        <span>Understanding async/await and asynchronous operations</span>
    </h2>
</doc-anchor-target>
<p>Understanding asynchronous operations and the async/await pattern is essential for developing modern, efficient, scalable C# and .NET applications. Asynchronous programming has become increasingly important, especially in network programming, where operations such as web requests, file I/O, and database transactions can significantly impact performance and responsiveness. The async and await keywords in C# facilitate asynchronous programming by allowing developers to write code that is both efficient and easy to read and closely resembles traditional synchronous code structures.</p>
<p>The introduction of async/await has revolutionized how developers handle asynchronous tasks, moving away from the cumbersome and error-prone patterns of the past to a more streamlined and intuitive approach. By marking a method with the <code v-pre>async</code> keyword, developers define a method that performs asynchronous operations and returns a <code v-pre>Task</code>, <code v-pre>Task&lt;T&gt;</code> or <code v-pre>ValueTask&lt;T&gt;</code>. The <code v-pre>await</code> keyword is then used to call these asynchronous methods, enabling the current method to pause its execution until the awaited task completes without blocking the thread. This model enhances the responsiveness of applications, particularly in UI environments and network solutions, by preventing the UI from freezing and improving the overall user experience. Understanding and applying these concepts and .NET is crucial for developers aiming to leverage the full power of modern programming techniques in their applications.</p>
<doc-anchor-target id="asyncawait-fundamentals">
    <h3>
        <doc-anchor-trigger class="header-anchor-trigger" to="#asyncawait-fundamentals">#</doc-anchor-trigger>
        <span>Async/await fundamentals</span>
    </h3>
</doc-anchor-target>
<p>In C#, the <code v-pre>async</code> and <code v-pre>await</code> keywords form the cornerstone of asynchronous programming, enabling developers to write cleaner, more readable code for asynchronous operations. The <code v-pre>async</code> keyword defines a method as asynchronous, indicating that the method contains operations that may involve waiting, such as network calls or file I/O, without blocking the executing thread. When marked async, a method returns a <code v-pre>Task</code>, <code v-pre>Task&lt;T&gt;</code> or <code v-pre>ValueTask&lt;T&gt;</code>, representing ongoing work. The <code v-pre>await</code> keyword, used within async methods, pauses the execution of the method until the awaited Task completes, allowing other operations to run concurrently without locking the main thread. This combination simplifies coding for asynchronous tasks, making it easier to manage and maintain while improving application performance and responsiveness.</p>
<doc-anchor-target id="the-async-modifier">
    <h4>
        <doc-anchor-trigger class="header-anchor-trigger" to="#the-async-modifier">#</doc-anchor-trigger>
        <span>The async modifier</span>
    </h4>
</doc-anchor-target>
<p>The <code v-pre>async</code> method modifier in C# indicates that a method, lambda expression, or anonymous method is asynchronous. Methods marked with async often contain one or more await expressions or statements, indicating points at which the method can yield control back to its caller until the awaited asynchronous operation completes. The presence of async modifies the method&#x27;s return type, enabling it to return <code v-pre>Task</code>, <code v-pre>Task&lt;T&gt;</code>, or <code v-pre>ValueTask&lt;T&gt;</code>, which represent ongoing work that might not yet be complete. This approach is essential for non-blocking application development, particularly in UI applications or services where responsiveness and scalability are crucial.</p>
<p>Without async (Synchronous Code):</p>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-csharp"><code v-pre class="language-csharp">public List&lt;string&gt; GetCustomerNames()
{
    // Imagine this method calls a database and returns a list of names
    Thread.Sleep(5000); // Simulate a time-consuming operation
    return new List&lt;string&gt; { &quot;John Doe&quot;, &quot;Jane Doe&quot; };
}</code></pre>
</doc-codeblock></div>
<p>In this synchronous example, calling <code v-pre>GetCustomerNames()</code> blocks the calling thread until the method completes, which simulates a time-consuming database operation. This blocking can lead to a poor user experience in UI applications or reduced scalability in services due to thread pool exhaustion.</p>
<p>With async and await (Asynchronous Code):</p>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-csharp"><code v-pre class="language-csharp">public async Task&lt;List&lt;string&gt;&gt; GetCustomerNamesAsync()
{
    // Simulate an asynchronous time-consuming operation
    await Task.Delay(5000); // This line yields control until the delay completes, without blocking the thread.
    return new List&lt;string&gt; { &quot;John Doe&quot;, &quot;Jane Doe&quot; };
}</code></pre>
</doc-codeblock></div>
<p>In the asynchronous version, <code v-pre>GetCustomerNamesAsync()</code> method is marked with async, indicating it contains asynchronous operations, namely <code v-pre>Task.Delay(5000)</code> awaited by <code v-pre>await</code>. This setup allows the method to yield control back to the caller during the await on <code v-pre>Task.Delay</code>, enabling other operations to run concurrently on the calling thread. Once the delay completes, execution resumes, and the method eventually returns a <code v-pre>Task&lt;List&lt;string&gt;&gt;</code>. This pattern maintains application responsiveness and service scalability by avoiding blocking calls and efficiently utilizing threads.</p>
<doc-anchor-target id="the-await-keyword">
    <h4>
        <doc-anchor-trigger class="header-anchor-trigger" to="#the-await-keyword">#</doc-anchor-trigger>
        <span>The await keyword</span>
    </h4>
</doc-anchor-target>
<p>The <code v-pre>await</code> keyword in C# is a pivotal feature of asynchronous programming, used in conjunction with the async modifier. It allows the current method to pause its execution until the awaited asynchronous task is complete without blocking the calling thread. Control returns to the caller during this wait, enabling other operations to run concurrently. This mechanism is crucial for developing responsive applications, especially when dealing with IO-bound tasks like reading files, database operations, or making web requests. The beauty of await lies in its ability to write asynchronous code as straightforward and readable as its synchronous counterpart.</p>
<p>Here&#x27;s a simple example demonstrating the difference between synchronous and asynchronous execution in C#.</p>
<p>Without await (Synchronous Code):</p>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-csharp"><code v-pre class="language-csharp">public string ReadFileContent()
{
    using (var reader = new StreamReader(&quot;example.txt&quot;))
    {
        return reader.ReadToEnd(); // This line blocks the calling thread until the file is read.
    }
}</code></pre>
</doc-codeblock></div>
<p>In the synchronous version, the call to <code v-pre>ReadToEnd()</code> blocks the calling thread until the entire file content is read. This can lead to application unresponsiveness, especially with large files or slow IO operations.</p>
<p>With await (Asynchronous Code):</p>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-csharp"><code v-pre class="language-csharp">public async Task&lt;string&gt; ReadFileContentAsync()
{
    using (var reader = new StreamReader(&quot;example.txt&quot;))
    {
        return await reader.ReadToEndAsync(); // This line does not block the calling thread.
    }
}</code></pre>
</doc-codeblock></div>
<p>In the asynchronous version, the method is marked with async, and await is used with <code v-pre>ReadToEndAsync()</code>. This tells the compiler to pause the execution of <code v-pre>ReadFileContentAsync</code> until <code v-pre>ReadToEndAsync</code> completes without blocking the calling thread. During this wait, control is returned to the calling method, allowing other operations to proceed concurrently. Once the awaited task completes, execution resumes after the await line. This approach significantly improves applications&#x27; responsiveness by freeing up the calling thread to handle other tasks while waiting for IO operations to complete.</p>
<doc-anchor-target id="strategies-for-writing-asynchronous-code">
    <h2>
        <doc-anchor-trigger class="header-anchor-trigger" to="#strategies-for-writing-asynchronous-code">#</doc-anchor-trigger>
        <span>Strategies for writing asynchronous code</span>
    </h2>
</doc-anchor-target>
<p>Writing asynchronous code is essential in modern software development, especially when building scalable, responsive applications and services. The asynchronous programming model in languages like C# allows developers to perform non-blocking operations, such as web requests, file IO, and database transactions, thereby improving user interface responsiveness and the scalability of backend services. However, effectively harnessing this model requires thoughtful strategies to manage the inherent complexities of asynchronous code, such as potential deadlocks, maintaining code clarity, and handling exceptions.</p>
<p>One key strategy is to embrace the <code v-pre>async</code> and <code v-pre>await</code> keywords in C#, which simplifies asynchronous programming by allowing developers to write code that appears synchronous but executes asynchronously. This approach helps avoid common pitfalls like blocking calls that can lead to application freezes or inefficient resource use. Furthermore, adopting an &quot;async all the way down&quot; approach ensures that asynchronous calls do not mix with synchronous blocking calls, which can cause deadlocks and reduce scalability. Additionally, developers should structure their code to handle exceptions gracefully and avoid unobserved exceptions in asynchronous operations. Developers can create efficient, scalable, and responsive applications by combining these strategies with best practices like minimizing thread usage and leveraging asynchronous libraries and frameworks.</p>
<doc-anchor-target id="know-when-to-use-asyncawait">
    <h3>
        <doc-anchor-trigger class="header-anchor-trigger" to="#know-when-to-use-asyncawait">#</doc-anchor-trigger>
        <span>Know When to Use async/await</span>
    </h3>
</doc-anchor-target>
<p>In networking software, where operations often involve significant latency due to data transmission over the network, the C# async/await pattern emerges as a powerful paradigm for enhancing efficiency and responsiveness. This model is particularly advantageous in scenarios where I/O-bound work dominates, such as web service calls, database access, and any form of data exchange over the internet or intranet. Utilizing async/await allows applications to remain responsive to user interactions or other tasks while waiting for network responses, which can take unpredictable time due to varying network speeds and latencies.</p>
<p>But when exactly should you look to use async/await? Here are a few pointers:</p>
<ul>
<li><strong>Long-running network calls</strong>: Async and await should be your go-to whenever you&#x27;re making API calls, downloading files, or performing any network operation that takes more than a blink of an eye. They prevent your app from freezing up while waiting for the network to respond.</li>
<li><strong>UI responsiveness</strong>: Async programming is crucial if your application has a user interface and you need to maintain its responsiveness while performing network operations. It ensures that your app can still handle user interactions, like button clicks or scrolling, even when it&#x27;s busy fetching data from the web.</li>
<li><strong>Scalability</strong>: When writing server-side code, such as for a web service, using async and await can improve scalability. It lets your server handle more requests simultaneously by not tying up threads waiting for I/O operations to complete.</li>
<li><strong>Other I/O operations</strong>: When reading or writing files to disk or waiting for a long running database query, function or stored procedure, using async and await can help with performance also and allow the user to have a better experience using your app.</li>
</ul>
<p>Choosing when to apply async/await in networking software hinges on preventing blocking operations that can tie up system resources and degrade user experience or system throughput. For server-side applications, such as those built with ASP.NET, adopting async/await can significantly increase scalability by freeing up threads to serve more incoming requests while waiting for responses from external services or databases. On the client side, such as in desktop or mobile applications, using async/await ensures the UI remains responsive, providing feedback to the user that operations are in progress rather than the application appearing frozen. It&#x27;s crucial, however, to apply async/await judiciously, reserving its use for truly asynchronous operations to avoid unnecessary overhead and complexity in application code. This strategic application ensures that the benefits of asynchronous programming—such as improved responsiveness and scalability—are fully realized without introducing undue complexity or performance penalties.</p>
<doc-anchor-target id="async-method-design">
    <h3>
        <doc-anchor-trigger class="header-anchor-trigger" to="#async-method-design">#</doc-anchor-trigger>
        <span>Async method design</span>
    </h3>
</doc-anchor-target>
<p>Async method design in C# is a powerful feature for improving the scalability and responsiveness of applications, particularly important in scenarios involving IO-bound operations, such as web requests, file access, and database transactions. By using the async and await keywords, developers can write asynchronous code that is almost as straightforward to read and write as synchronous code. This design pattern allows a method to run asynchronously without blocking the thread on which it is executed, making it especially useful for creating smooth user interfaces and efficient server-side applications.</p>
<p>The cornerstone of async method design is understanding when and how to apply it effectively. This involves marking a method with the async modifier, which enables the use of the await keyword within it to await asynchronous operations instead of blocking them. Such methods typically return a <code v-pre>Task</code>, <code v-pre>Task&lt;T&gt;</code> or <code v-pre>ValueTask&lt;T&gt;</code> to represent the ongoing operation. Developers must grasp the flow of control in asynchronous methods, ensuring they avoid common pitfalls like deadlocks, excessive resource consumption, and the complexity of error handling in asynchronous code paths. Mastering async method design leads to responsive and efficient applications, leveraging the underlying asynchronous programming model to its full potential.</p>
<doc-anchor-target id="async-all-the-way-down">
    <h4>
        <doc-anchor-trigger class="header-anchor-trigger" to="#async-all-the-way-down">#</doc-anchor-trigger>
        <span>Async all the way down</span>
    </h4>
</doc-anchor-target>
<p>In developing networking software with C#, employing async and await comprehensively, from the user interface down to the lowest network operations, is crucial for enhancing application responsiveness and performance. These keywords are instrumental in executing IO-bound operations, such as HTTP requests, file transfers, or database queries, asynchronously to prevent blocking the main thread. This approach allows your application to perform other tasks while waiting for network responses, avoiding application freezes and server bottlenecks.</p>
<p>Adopting an &quot;async all the way down&quot; strategy means consistently applying asynchronous programming principles throughout your codebase whenever you initiate an asynchronous operation. This consistency is critical in avoiding common issues like deadlocks, which can arise from mixing synchronous and asynchronous code. It&#x27;s essential, however, to apply <code v-pre>async</code> and <code v-pre>await</code> judiciously. Not all methods benefit from asynchrony, especially those that are not IO-bound or where the overhead of asynchrony might outweigh its benefits. Furthermore, integrating asynchronous code requires a solid understanding of its patterns and potential pitfalls, such as the risk of deadlocks when improperly mixing sync and async code and the performance overhead associated with task management and context switching. In summary, using async and await throughout your networking code can significantly improve your application&#x27;s efficiency and user experience, provided it&#x27;s applied thoughtfully and where it&#x27;s most effective.</p>
<doc-anchor-target id="avoid-async-void">
    <h4>
        <doc-anchor-trigger class="header-anchor-trigger" to="#avoid-async-void">#</doc-anchor-trigger>
        <span>Avoid async Void</span>
    </h4>
</doc-anchor-target>
<p>A common best practice in C# asynchronous programming is to avoid <code v-pre>async void</code> methods, except in specific scenarios such as event handlers. The primary reason for this guidance is the exception handling behavior of <code v-pre>async void</code> methods, which can lead to unhandled exceptions that crash the application. Unlike <code v-pre>async Task</code> methods, where exceptions are captured and can be observed and handled by the caller, exceptions thrown in async void methods are propagated to the synchronization context and are not easily caught. This behavior makes debugging and error handling significantly more challenging, as the application might terminate unexpectedly without clearly indicating the source error.</p>
<p>Moreover, <code v-pre>async void</code> methods hinder composability and testability in asynchronous code. Since they do not return a <code v-pre>Task</code>, callers cannot await them, making it difficult to know when the operation has completed and to handle exceptions properly. This limitation is particularly problematic in unit testing, where the ability to await and observe the completion of asynchronous operations is crucial for verifying behavior and ensuring test reliability. For these reasons, it&#x27;s recommended to use <code v-pre>async Task</code> or <code v-pre>async Task&lt;T&gt;</code> as the return type for asynchronous methods whenever possible, reserving async void strictly for event handlers and similar scenarios where it&#x27;s specifically required.</p>
<p>Here is a code example demonstrating why using <code v-pre>async void</code> can lead to issues, especially with exception handling, and how converting such a method to an async Task can improve your application&#x27;s error management and control flow.</p>
<p>Using async void:</p>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-csharp"><code v-pre class="language-csharp">public async void PerformAsyncOperation()
{
    try
    {
        // Simulate an asynchronous operation that fails
        await Task.Run(() =&gt; throw new InvalidOperationException(&quot;Error in async operation&quot;));
    }
    catch (Exception ex)
    {
        Console.WriteLine($&quot;Exception caught: {ex.Message}&quot;);
        // Exception is thrown here, but it's hard to handle properly,
        // potentially crashing the application.
    }
}

// Invocation of the async void method
// Note: There's no way to await this or catch exceptions thrown unless inside the method itself.
PerformAsyncOperation();</code></pre>
</doc-codeblock></div>
<p>In this <code v-pre>async void</code> example, if an exception is thrown within the <code v-pre>PerformAsyncOperation</code> method and not caught within the same method, it will propagate to the synchronization context and may crash the application. The caller also has no easy way to know when the operation has completed or to handle exceptions thrown by the operation.</p>
<p>Using async Task:</p>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-csharp"><code v-pre class="language-csharp">public async Task PerformAsyncOperationBetter()
{
    // This time, if an exception is thrown, it can be awaited and caught by the caller.
    await Task.Run(() =&gt; throw new InvalidOperationException(&quot;Error in async operation&quot;));
}

// Invocation with better exception handling
try
{
    await PerformAsyncOperationBetter();
}
catch (Exception ex)
{
    Console.WriteLine($&quot;Exception caught by caller: {ex.Message}&quot;);
    // Now the caller can handle exceptions, making the code more robust and less prone to unexpected crashes.
}</code></pre>
</doc-codeblock></div>
<p>By using <code v-pre>async Task</code> instead of <code v-pre>async void</code>, the method now returns a task that the caller can await. This change allows exceptions to be propagated back to the caller, where they can be caught and handled appropriately. It also provides a clear completion point for the asynchronous operation, improving the control flow and making the code safer and more maintainable.</p>
<doc-anchor-target id="task-handling">
    <h3>
        <doc-anchor-trigger class="header-anchor-trigger" to="#task-handling">#</doc-anchor-trigger>
        <span>Task handling</span>
    </h3>
</doc-anchor-target>
<p>Using <code v-pre>Tasks</code> for asynchronous programming is a powerful paradigm that enables developers to write non-blocking code, improving the responsiveness and scalability of applications. By leveraging the Task and Task<T> classes, along with the async and await keywords, this approach allows long-running operations such as file I/O, network requests, and other IO-bound or CPU-bound operations to run in the background, freeing the main thread to continue processing other tasks. This is particularly beneficial in user interface applications to prevent freezing and in server-side applications to handle multiple concurrent requests efficiently.</p>
<p>The <code v-pre>Task</code> class represents an asynchronous operation that can return a value (<code v-pre>Task&lt;T&gt;</code>) or no value (<code v-pre>Task</code>). When a method is marked with the async modifier, it signifies that the method contains asynchronous operations and may use the <code v-pre>await</code> keyword to pause its execution until the awaited <code v-pre>Task</code> completes. This model simplifies error handling, improves application throughput, and enhances user experiences by making asynchronous programming more accessible and manageable. Adopting Tasks and async/await transforms how developers architect applications, promoting a more responsive, scalable, and maintainable codebase.</p>
<doc-anchor-target id="return-tasks-from-asynchronous-methods">
    <h4>
        <doc-anchor-trigger class="header-anchor-trigger" to="#return-tasks-from-asynchronous-methods">#</doc-anchor-trigger>
        <span>Return tasks from asynchronous methods</span>
    </h4>
</doc-anchor-target>
<p>In C#, when methods call other asynchronous methods and return a <code v-pre>Task</code>, <code v-pre>Task&lt;T&gt;</code> or <code v-pre>ValueTask&lt;T&gt;</code>, it&#x27;s crucial to handle these tasks properly to maintain efficiency and responsiveness in your application. Asynchronous methods, marked with the <code v-pre>async</code> keyword, typically use await to pause their execution until the awaited task completes. This approach enables the calling thread to be used for other work rather than blocking until the task finishes, which is particularly beneficial in I/O-bound operations or UI applications where responsiveness is vital.</p>
<p>Let&#x27;s look at examples to illustrate the difference between handling methods that return a <code v-pre>Task</code> improperly and the recommended approach using await.</p>
<p>Without Accepting a Task (Improper Handling)</p>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-csharp"><code v-pre class="language-csharp">public class DigitalKitchen
{
    private string BakeCake()
    {
        Console.WriteLine(&quot;Cake baking started.&quot;);
        Thread.Sleep(4000); // Simulating baking time.
        Console.WriteLine(&quot;Cake is ready!&quot;);
        return &quot;Chocolate Cake&quot;;
    }

    private string PrepareSalad()
    {
        Console.WriteLine(&quot;Salad preparation started.&quot;);
        Thread.Sleep(2000); // Simulating chopping and mixing time.
        Console.WriteLine(&quot;Salad is ready!&quot;);
        return &quot;Greek Salad&quot;;
    }

    private string BrewCoffee()
    {
        Console.WriteLine(&quot;Coffee brewing started.&quot;);
        Thread.Sleep(3000); // Simulating brewing time.
        Console.WriteLine(&quot;Coffee is ready!&quot;);
        return &quot;Espresso&quot;;
    }

    public void PrepareDinner()
    {
        // Each method completes before the next starts.
        string cake = BakeCake();
        string salad = PrepareSalad();
        string coffee = BrewCoffee();

        Console.WriteLine($&quot;Dinner is ready with: {cake}, {salad}, {coffee}&quot;);
    }
}

// Usage:
var kitchen = new DigitalKitchen();
kitchen.PrepareDinner();</code></pre>
</doc-codeblock></div>
<p>The previous code example does not utilize asynchronous programming (<code v-pre>Task</code> or<code v-pre> Task&lt;T&gt;</code>) to manage the preparation tasks. As a result, the <code v-pre>PrepareDinner</code> method is less efficient than it could be, because it does not allow for the concurrent preparation of the dinner items. In a real-world scenario, these tasks could potentially be performed in parallel (e.g., baking a cake while also brewing coffee), which would reduce the overall preparation time.</p>
<p>With Tasks (Efficient Handling)</p>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-csharp"><code v-pre class="language-csharp">public class DigitalKitchen
{
    private async Task&lt;string&gt; BakeCakeAsync()
    {
        Console.WriteLine(&quot;Cake baking started.&quot;);
        await Task.Delay(4000); // Simulating baking time.
        Console.WriteLine(&quot;Cake is ready!&quot;);
        return &quot;Chocolate Cake&quot;;
    }

    private async Task&lt;string&gt; PrepareSaladAsync()
    {
        Console.WriteLine(&quot;Salad preparation started.&quot;);
        await Task.Delay(2000); // Simulating chopping and mixing time.
        Console.WriteLine(&quot;Salad is ready!&quot;);
        return &quot;Greek Salad&quot;;
    }

    private async Task&lt;string&gt; BrewCoffeeAsync()
    {
        Console.WriteLine(&quot;Coffee brewing started.&quot;);
        await Task.Delay(3000); // Simulating brewing time.
        Console.WriteLine(&quot;Coffee is ready!&quot;);
        return &quot;Espresso&quot;;
    }

    public async Task PrepareDinnerAsync()
    {
        // Starting all tasks without waiting for any to complete.
        var cakeTask = BakeCakeAsync();
        var saladTask = PrepareSaladAsync();
        var coffeeTask = BrewCoffeeAsync();

        // Now, await all tasks, effectively not waiting for each individually but letting them run concurrently.
        var dinnerItems = await Task.WhenAll(cakeTask, saladTask, coffeeTask);
        
        Console.WriteLine($&quot;Dinner is ready with: {string.Join(&quot;, &quot;, dinnerItems)}&quot;);
    }
}

// Usage:
var kitchen = new DigitalKitchen();
await kitchen.PrepareDinnerAsync();</code></pre>
</doc-codeblock></div>
<p>In this asynchronous version, the <code v-pre>PrepareDinnerAsync</code> method initiates all preparation tasks simultaneously and then awaits completion using <code v-pre>Task.WhenAll</code>. This method efficiently overlaps the preparation times, reducing the total preparation time to the duration of the most prolonged task, rather than the sum of all task durations. This example showcases the potential efficiency gains from applying asynchronous programming techniques.</p>
<doc-anchor-target id="avoid-premature-await">
    <h4>
        <doc-anchor-trigger class="header-anchor-trigger" to="#avoid-premature-await">#</doc-anchor-trigger>
        <span>Avoid premature await</span>
    </h4>
</doc-anchor-target>
<p>In the realm of asynchronous programming with C#, a common pitfall is the premature use of await on asynchronous operations when it&#x27;s not immediately necessary. This practice can lead to inefficient use of concurrency and potentially increase the overall execution time of an application. Avoiding premature await lies in recognizing opportunities to execute multiple asynchronous operations in parallel rather than sequentially. When await is applied too early in the code, it forces the program to wait for the completion of an operation before moving on to the next, which can negate the benefits of non-blocking IO operations that asynchronous programming aims to provide.</p>
<p>To harness the full potential of asynchrony, developers are encouraged to initiate all possible asynchronous operations first and await their results closer to the point of use. This approach allows multiple tasks to run concurrently, maximizing throughput and reducing response times, particularly in IO-bound scenarios such as web requests, database operations, or file access. Understanding when to await tasks is crucial in designing efficient, responsive applications. By structuring asynchronous code to delay await as long as practical, developers can ensure that their applications use system resources optimally, achieving better scalability and performance.</p>
<p>Premature <code v-pre>await</code> example</p>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-csharp"><code v-pre class="language-csharp">public class DataService
{
    public async Task&lt;string&gt; GetDataFromAPIAsync(string url)
    {
        // Simulate an asynchronous web request
        await Task.Delay(1000); // Wait for 1 second to mimic network delay
        return $&quot;Data from {url}&quot;;
    }

    public async Task ProcessDataSequentiallyAsync()
    {
        string data1 = await GetDataFromAPIAsync(&quot;https://api.example.com/data1&quot;);
        string data2 = await GetDataFromAPIAsync(&quot;https://api.example.com/data2&quot;);
        string data3 = await GetDataFromAPIAsync(&quot;https://api.example.com/data3&quot;);

        Console.WriteLine(data1);
        Console.WriteLine(data2);
        Console.WriteLine(data3);
    }
}</code></pre>
</doc-codeblock></div>
<p>In the above code, <code v-pre>ProcessDataSequentiallyAsync</code> waits for each web request to complete before initiating the next one, which is not efficient, especially when the calls are independent of each other.</p>
<p>Avoiding Premature <code v-pre>await</code></p>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-csharp"><code v-pre class="language-csharp">public class DataService
{
    public async Task&lt;string&gt; GetDataFromAPIAsync(string url)
    {
        // Simulate an asynchronous web request
        await Task.Delay(1000); // Wait for 1 second to mimic network delay
        return $&quot;Data from {url}&quot;;
    }

    public async Task ProcessDataInParallelAsync()
    {
        Task&lt;string&gt; dataTask1 = GetDataFromAPIAsync(&quot;https://api.example.com/data1&quot;);
        Task&lt;string&gt; dataTask2 = GetDataFromAPIAsync(&quot;https://api.example.com/data2&quot;);
        Task&lt;string&gt; dataTask3 = GetDataFromAPIAsync(&quot;https://api.example.com/data3&quot;);

        // Await all tasks to complete
        var results = await Task.WhenAll(dataTask1, dataTask2, dataTask3);

        foreach (var result in results)
        {
            Console.WriteLine(result);
        }
    }
}</code></pre>
</doc-codeblock></div>
<p>In this optimized version, <code v-pre>ProcessDataInParallelAsync</code> initiates all web requests concurrently by storing the tasks in variables without immediately awaiting them. Only after all tasks have been started does it await their completion using <code v-pre>Task.WhenAll</code>. This approach significantly reduces the total execution time, as the network requests are made in parallel, showcasing the advantage of avoiding premature await.</p>
<doc-anchor-target id="avoiding-premature-async">
    <h3>
        <doc-anchor-trigger class="header-anchor-trigger" to="#avoiding-premature-async">#</doc-anchor-trigger>
        <span>Avoiding premature async</span>
    </h3>
</doc-anchor-target>
<p>Premature async refers to the unnecessary or excessive use of asynchronous programming where it does not provide benefits and might even degrade performance. For example, marking a method as <code v-pre>async</code> solely to use the <code v-pre>await</code> keyword on a method that internally performs a quick, in-memory operation or wraps synchronous code without actual I/O operations can lead to overhead without any real concurrency benefit. This increases the code&#x27;s complexity and can also introduce overhead associated with context switching and increased memory usage due to state machine generation in the background.</p>
<p>Asynchronous methods in .NET create a state machine behind the scenes when you use the async and await keywords. While this is excellent for actual asynchronous I/O operations (like network calls, file I/O, or database queries), applying async/await to methods that execute quickly or are computationally bound (rather than I/O bound) can negatively impact performance. The overhead of setting up and tearing down the state machine and the potential for more frequent garbage collection can make an async method slower than its synchronous counterpart. Additionally, misuse of asynchronous programming can lead to more complex codebases that are harder to maintain and debug, especially regarding error handling and understanding control flow.</p>
<doc-anchor-target id="error-handling">
    <h3>
        <doc-anchor-trigger class="header-anchor-trigger" to="#error-handling">#</doc-anchor-trigger>
        <span>Error handling</span>
    </h3>
</doc-anchor-target>
<p>Asynchronous programming with async and await provides a powerful paradigm for writing non-blocking, responsive applications, especially useful in I/O-bound operations such as web requests, file operations, and database queries. However, with the shift from synchronous to asynchronous code, error handling undergoes a transformation that requires careful consideration. In asynchronous programming, exceptions are captured and stored within the task returned by an async method. This means the traditional try-catch blocks used for synchronous methods must be thoughtfully applied to async methods to catch and handle exceptions effectively.</p>
<p>When an exception is thrown within an async method, it is encapsulated within the returned <code v-pre>Task</code> object. If the task is awaited, the exception is rethrown when the await expression is evaluated. This allows developers to use try-catch blocks around await statements to catch exceptions from async methods, similar to how they would with synchronous code. However, suppose a Task is not awaited, or the result of an async operation is accessed without awaiting it. In that case, exceptions can go unobserved, resulting in unhandled exceptions that can crash the application or lead to unexpected behavior.</p>
<p>To ensure robust error handling in async programming, developers must ensure that all tasks are adequately awaited and encapsulated within try-catch blocks as necessary. To handle multiple tasks running in parallel, use Task.WhenAll can aggregate multiple exceptions into a single AggregateException, which can then be caught and handled. Additionally, leveraging task continuation options like Task.ContinueWith can provide more granular control over exception handling and task orchestration. Careful management of task exceptions is crucial in maintaining the reliability and stability of asynchronous C# applications, making error handling an essential skill in the async programming toolkit.</p>
<doc-anchor-target id="exception-handling-in-async-code">
    <h4>
        <doc-anchor-trigger class="header-anchor-trigger" to="#exception-handling-in-async-code">#</doc-anchor-trigger>
        <span>Exception handling in async code</span>
    </h4>
</doc-anchor-target>
<p>Handling exceptions properly in asynchronous programming is crucial to maintain application stability and provide a robust user experience. When exceptions are not correctly handled in asynchronous methods, it can lead to unhandled exceptions that might crash the application or cause erratic behavior. Correctly handling exceptions in async tasks involves using try-catch blocks around await statements or strategically capturing exceptions from returned tasks. Below are two examples demonstrating improper and proper exception handling async programming.</p>
<p>This example demonstrates what happens when an exception thrown in an async method is not properly handled. The exception is thrown but not caught because there&#x27;s no try-catch block encapsulating the await call.</p>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-csharp"><code v-pre class="language-csharp">public class Example
{
    public async Task ThrowExceptionAsync()
    {
        throw new InvalidOperationException(&quot;An error occurred.&quot;);
    }

    public async Task CallAsyncMethod()
    {
        await ThrowExceptionAsync(); // Exception thrown here is not caught
    }
}

// Usage
var example = new Example();
await example.CallAsyncMethod(); // This will result in an unhandled exception</code></pre>
</doc-codeblock></div>
<p>Now, let&#x27;s correctly write some error-handling code:</p>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-csharp"><code v-pre class="language-csharp">public class Example
{
    public async Task ThrowExceptionAsync()
    {
        throw new InvalidOperationException(&quot;An error occurred.&quot;);
    }

    public async Task CallAsyncMethodAndHandleException()
    {
        try
        {
            await ThrowExceptionAsync();
        }
        catch (InvalidOperationException ex)
        {
            Console.WriteLine($&quot;Exception caught: {ex.Message}&quot;);
            // Exception is handled here, preventing the application from crashing
        }
    }
}

// Usage
var example = new Example();
await example.CallAsyncMethodAndHandleException(); // Exception is handled properly</code></pre>
</doc-codeblock></div>
<p>In the second example, the try-catch block effectively catches and handles the exception thrown by the <code v-pre>ThrowExceptionAsync</code> method, showcasing the correct way to manage exceptions in asynchronous C# programming. This approach ensures that exceptions do not go unhandled, thereby improving the application&#x27;s reliability and user experience.</p>
<p>In the vibrant landscape of asynchronous programming, programmers can encounter several specialized types of exceptions beyond the usual suspects of runtime exceptions. These unique challenges require their strategies and capes to conquer.</p>
<p>First off, we will examine the <code v-pre>TaskCanceledException</code> exception. Handling TaskCanceledException is crucial in asynchronous programming, especially when working with tasks that can be canceled, such as long-running operations or network requests. The <code v-pre>TaskCanceledException</code> is thrown when a task is canceled, typically through the use of a <code v-pre>CancellationToken</code>. Proper handling of this exception allows your application to respond gracefully to cancellation requests, improving responsiveness and user experience. Below is an example demonstrating how to handle <code v-pre>TaskCanceledException</code> in an asynchronous method.</p>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-csharp"><code v-pre class="language-csharp">public class Example
{
    public async Task LongRunningOperationAsync(CancellationToken cancellationToken)
    {
        try
        {
            // Simulating a long-running task
            Console.WriteLine(&quot;Operation started.&quot;);
            await Task.Delay(5000, cancellationToken); // Wait for 5 seconds or until canceled
            Console.WriteLine(&quot;Operation completed successfully.&quot;);
        }
        catch (TaskCanceledException)
        {
            Console.WriteLine(&quot;Operation was canceled.&quot;);
            // Additional cleanup or rollback actions can be performed here
        }
    }
}

public class Program
{
    public static async Task Main(string[] args)
    {
        CancellationTokenSource cts = new CancellationTokenSource();
        var example = new Example();

        Task runTask = example.LongRunningOperationAsync(cts.Token);

        // Cancel the operation after 1 second to trigger TaskCanceledException
        Task.Delay(1000).ContinueWith(_ =&gt; cts.Cancel());

        await runTask; // This awaits the completion of the long-running operation, including handling cancellation
    }
}
</code></pre>
</doc-codeblock></div>
<p>In the previous code, <code v-pre>LongRunningOperationAsync</code> is designed to perform a task that lasts for 5 seconds. However, we introduce a <code v-pre>CancellationToken</code> and cancel the operation after 1 second. When the task is canceled, <code v-pre>Task.Delay</code> throws a <code v-pre>TaskCanceledException</code>, which we catch and handle by printing a message to the console. This demonstrates how to gracefully handle task cancellation in an asynchronous C# application, allowing for proper cleanup and user feedback when operations are interrupted.</p>
<p>The <code v-pre>AggregateException</code> is used to represent multiple exceptions that may occur during the execution of tasks that are run concurrently. This exception type is particularly common when using <code v-pre>Task.WhenAll</code> to await multiple tasks simultaneously. Handling <code v-pre>AggregateException</code> correctly is essential for robust error management in applications that perform parallel operations.</p>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-csharp"><code v-pre class="language-csharp">public class Example
{
    public async Task Operation1Async()
    {
        // Simulating an operation that fails
        await Task.Delay(100); // Simulate work
        throw new InvalidOperationException(&quot;Operation 1 failed.&quot;);
    }

    public async Task Operation2Async()
    {
        // Simulating another operation that also fails
        await Task.Delay(100); // Simulate work
        throw new AccessViolationException(&quot;Operation 2 failed.&quot;);
    }

    public async Task RunParallelOperationsAsync()
    {
        Task task1 = Operation1Async();
        Task task2 = Operation2Async();

        try
        {
            await Task.WhenAll(task1, task2);
        }
        catch (Exception ex) when (ex is AggregateException || ex is InvalidOperationException || ex is AccessViolationException)
        {
            if (ex is AggregateException aggEx)
            {
                Console.WriteLine(&quot;Handling AggregateException:&quot;);
                foreach (var innerEx in aggEx.InnerExceptions)
                {
                    Console.WriteLine($&quot; - {innerEx.GetType()}: {innerEx.Message}&quot;);
                }
            }
            else
            {
                // Single exception handling logic
                Console.WriteLine($&quot;{ex.GetType()}: {ex.Message}&quot;);
            }
        }
    }
}

public class Program
{
    public static async Task Main(string[] args)
    {
        var example = new Example();
        await example.RunParallelOperationsAsync();
    }
}</code></pre>
</doc-codeblock></div>
<p>By effectively understanding and managing these exceptions, developers can guarantee that their asynchronous C# projects conclude successfully rather than fail. Therefore, it is crucial to arm yourself with the necessary knowledge and coding practices for asynchronous programming.</p>
<doc-anchor-target id="efficient-use-of-resources">
    <h3>
        <doc-anchor-trigger class="header-anchor-trigger" to="#efficient-use-of-resources">#</doc-anchor-trigger>
        <span>Efficient use of resources</span>
    </h3>
</doc-anchor-target>
<p>Efficient resource use in asynchronous programming is vital for creating scalable and performant applications. Asynchronous operations, particularly those involving I/O activities such as file access, network communications, or database transactions, should be managed carefully to avoid unnecessary resource consumption. Efficiently handling resources in async tasks ensures that the application maximizes throughput and minimizes latency, providing a smooth user experience even under heavy load. This involves strategically acquiring resources just before they&#x27;re needed and releasing them promptly after use, thus reducing the likelihood of resource contention and exhaustion.</p>
<p>In the context of C# asynchronous programming, adopting patterns that facilitate the efficient use of resources can significantly impact the application&#x27;s responsiveness and scalability. Practices such as leveraging <code v-pre>using</code> statements for automatic resource management, properly awaiting asynchronous operations without blocking, and minimizing the scope of resource utilization are critical. By embracing these practices, developers can build applications that perform well under various conditions, maintain resource integrity, and prevent leaks, ensuring long-term stability and reliability.</p>
<doc-anchor-target id="configureawaitfalse">
    <h4>
        <doc-anchor-trigger class="header-anchor-trigger" to="#configureawaitfalse">#</doc-anchor-trigger>
        <span>ConfigureAwait(false)</span>
    </h4>
</doc-anchor-target>
<p>In C# asynchronous programming, <code v-pre>ConfigureAwait(false)</code> is crucial in enhancing performance and avoiding deadlocks, especially in library code or applications not directly interacting with UI elements. When you await an async operation, by default, the continuation (the code that follows the await) attempts to resume on the original context (e.g., the UI thread in a desktop application). This behavior ensures that the UI remains responsive and that UI elements can be safely updated after asynchronous operations. However, this can lead to deadlocks if the original context is blocked while waiting for the async operation to complete. Furthermore, in non-UI scenarios like server-side code, forcing continuations to marshal back to the original context can unnecessarily hurt performance. <code v-pre>ConfigureAwait(false)</code> instructs the awaiter not to capture and marshal the continuation back to the original context, thereby improving efficiency and reducing the risk of deadlocks in specific scenarios.</p>
<p>In library code, where you don&#x27;t know whether the consumer will call your async methods in a UI context, <code v-pre>ConfigureAwait(false)</code> is recommended. This better practice can lead to more performant and deadlock-free code. However, it&#x27;s important to note that when using <code v-pre>ConfigureAwait(false)</code>, you must ensure that any code following the await does not interact with UI elements or assume execution on the original context. This distinction helps prevent runtime errors and ensures the application behaves as expected across different execution environments.</p>
<p>Without <code v-pre>ConfigureAwait(false)</code></p>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-csharp"><code v-pre class="language-csharp">public async Task&lt;string&gt; GetDataAsync()
{
    using (var httpClient = new HttpClient())
    {
        string result = await httpClient.GetStringAsync(&quot;http://example.com&quot;);
        // Continuation will attempt to run on the original context (e.g., UI thread)
        return result.ToUpper(); // Potential issue if the original context is blocked
    }
}</code></pre>
</doc-codeblock></div>
<p>The previous example might lead to deadlocks in a UI application if the UI thread is blocked waiting for this method to complete because the continuation attempts to resume on the UI thread.</p>
<p>With <code v-pre>ConfigureAwait(false)</code></p>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-csharp"><code v-pre class="language-csharp">public async Task&lt;string&gt; GetDataAsync()
{
    using (var httpClient = new HttpClient())
    {
        string result = await httpClient.GetStringAsync(&quot;http://example.com&quot;).ConfigureAwait(false);
        // Continuation does not marshal back to the original context
        return result.ToUpper(); // Safe, as no UI elements are accessed and original context is not assumed
    }
}</code></pre>
</doc-codeblock></div>
<p>In the second example, <code v-pre>ConfigureAwait(false)</code> is used to prevent the awaiter from attempting to resume the continuation on the original synchronization context. This approach is beneficial in library code and any situation where the continuation code does not need to run on the original context, improving performance and reducing deadlock risks</p>
<doc-anchor-target id="concurrency-and-synchronization">
    <h3>
        <doc-anchor-trigger class="header-anchor-trigger" to="#concurrency-and-synchronization">#</doc-anchor-trigger>
        <span>Concurrency and synchronization</span>
    </h3>
</doc-anchor-target>
<p>Concurrency and synchronization are foundational concepts in asynchronous programming, playing a critical role in developing responsive and scalable applications. Concurrency involves running multiple operations in parallel, allowing applications to perform more efficiently by utilizing system resources optimally. Asynchronous programming facilitates concurrency by enabling operations that don&#x27;t depend on each other to execute simultaneously, thus improving throughput and application performance, especially in I/O-bound and network-bound scenarios. Performing asynchronous operations such as file access, database queries, and web requests without blocking the main thread is a hallmark of modern software development, providing a smooth user experience and efficient background processing.</p>
<p>However, with the power of concurrency comes the complexity of synchronization. Managing access to shared resources becomes crucial when multiple operations run concurrently to prevent race conditions, deadlocks, and other concurrency issues. Synchronization in asynchronous programming ensures that access to shared state is controlled and that operations are coordinated to maintain data integrity and application stability. C# offers various constructs for synchronization in asynchronous contexts, such as <code v-pre>async</code> and <code v-pre>await</code>, <code v-pre>Task.WhenAll</code>, <code v-pre>Task.WhenAny</code>, and synchronization primitives like <code v-pre>SemaphoreSlim</code> and <code v-pre>Mutex</code>, tailored for asynchronous operations.</p>
<p>Effective use of concurrency and synchronization in C# requires a deep understanding of asynchronous programming patterns and best practices. Developers must carefully design their applications to leverage concurrency for performance benefits while implementing synchronization mechanisms to avoid common pitfalls associated with parallel execution. By judiciously applying asynchronous programming techniques, developers can create applications that are not only fast and responsive but also robust and reliable, capable of easily handling complex operations and high loads.</p>
<doc-anchor-target id="managing-concurrency">
    <h4>
        <doc-anchor-trigger class="header-anchor-trigger" to="#managing-concurrency">#</doc-anchor-trigger>
        <span>Managing concurrency</span>
    </h4>
</doc-anchor-target>
<p>Managing concurrency asynchronous programming is crucial for writing efficient, scalable, and robust applications. Proper concurrency management ensures that asynchronous operations are executed in a controlled manner, maximizing resource utilization while avoiding common pitfalls such as race conditions and deadlocks. Unmanaged concurrency can lead to unpredictable behavior, where operations compete for resources, potentially leading to inefficiencies and errors. Conversely, effectively managing concurrency allows developers to execute multiple operations in parallel or sequentially, depending on the scenario, thereby improving application performance and responsiveness.</p>
<p>To effectively manage concurrency, developers can use various techniques and features provided by .NET, such as the <code v-pre>Task</code> class for creating and managing asynchronous operations, <code v-pre>Task.WhenAll</code> and <code v-pre>Task.WhenAny</code> for coordinating multiple tasks, and synchronization primitives for controlling access to shared resources. Proper application of these tools enables developers to harness the power of concurrency in their asynchronous C# applications, ensuring that operations are executed to optimize performance while maintaining data integrity and application stability.</p>
<p>This example below demonstrates unmanaged concurrency, where multiple asynchronous operations are launched without coordination, leading to potential resource contention and inefficiencies.</p>
<p><strong><em>Without Managed Concurrency</em></strong></p>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-csharp"><code v-pre class="language-csharp">public async Task ProcessDataAsync()
{
    var task1 = Task.Run(() =&gt; PerformOperationAsync(&quot;Operation 1&quot;));
    var task2 = Task.Run(() =&gt; PerformOperationAsync(&quot;Operation 2&quot;));
    var task3 = Task.Run(() =&gt; PerformOperationAsync(&quot;Operation 3&quot;));

    // Tasks are running concurrently without any explicit coordination
}

private async Task PerformOperationAsync(string operationName)
{
    // Simulate an asynchronous operation
    await Task.Delay(1000);
    Console.WriteLine($&quot;{operationName} completed.&quot;);
}</code></pre>
</doc-codeblock></div>
<p><strong><em>With Managed Concurrency</em></strong></p>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-csharp"><code v-pre class="language-csharp">public async Task ProcessDataAsync()
{
    var task1 = PerformOperationAsync(&quot;Operation 1&quot;);
    var task2 = PerformOperationAsync(&quot;Operation 2&quot;);
    var task3 = PerformOperationAsync(&quot;Operation 3&quot;);

    // Wait for all tasks to complete before proceeding
    await Task.WhenAll(task1, task2, task3);

    Console.WriteLine(&quot;All operations completed.&quot;);
}

private async Task PerformOperationAsync(string operationName)
{
    // Simulate an asynchronous operation
    await Task.Delay(1000);
    Console.WriteLine($&quot;{operationName} completed.&quot;);
}</code></pre>
</doc-codeblock></div>
<p>In the managed concurrency example, <code v-pre>Task.WhenAll</code> is used to await the completion of all asynchronous operations before moving on. This approach not only ensures that all operations have finished before proceeding but also allows these operations to run in parallel, demonstrating a balance between concurrency and coordination for optimal application performance.</p>
<doc-anchor-target id="key-practices-for-effective-async-and-await-code">
    <h3>
        <doc-anchor-trigger class="header-anchor-trigger" to="#key-practices-for-effective-async-and-await-code">#</doc-anchor-trigger>
        <span>Key practices for effective async and await code</span>
    </h3>
</doc-anchor-target>
<ol>
<li><strong>Use async for I/O-bound, not CPU-bound work</strong>: Apply <code v-pre>async</code> and <code v-pre>await</code> when the method involves I/O operations. Consider using other forms of concurrency and parallelism for CPU-bound tasks such as Task.Run to offload heavy computations to a background thread.</li>
<li><strong>Avoid async void</strong>: Always aim to return a <code v-pre>Task</code> or <code v-pre>Task&lt;T&gt;</code> from async methods. This practice enables exceptions to be properly returned to callers and makes your methods composable with other async tasks, empowering you in your coding practices.</li>
<li><strong>Minimize thread blocking</strong>: Ensure your async methods do not block threads by calling <code v-pre>.Result</code> or <code v-pre>.Wait()</code> on tasks. Instead, propagate async all the way through the call stack by converting calling methods to async and using await, thereby ensuring efficient code execution.</li>
<li><strong>Strategically apply ConfigureAwait(false)</strong>: When you&#x27;re sure that the continuation of an async method does not need to resume on the original synchronization context, you can use <code v-pre>ConfigureAwait(false)</code>. This can reduce the overhead of resuming the original context, which is instrumental in an application&#x27;s library code or non-UI components.</li>
<li><strong>Profile and measure</strong>: Always profile asynchronous code as you would synchronous code. Use profiling tools to measure whether async adds any real value in scenarios where you&#x27;ve applied it, adjusting your approach based on the findings.</li>
</ol>
<p>By adhering to these best practices, developers can avoid premature implementation of asynchronous code and ensure that ASP.NET Core applications are efficient, maintainable, and scalable. Proper usage of async and await helps manage resources effectively, keeping applications responsive under load without unnecessary performance costs.</p>
<doc-anchor-target id="summary">
    <h2>
        <doc-anchor-trigger class="header-anchor-trigger" to="#summary">#</doc-anchor-trigger>
        <span>Summary</span>
    </h2>
</doc-anchor-target>
<p>Let&#x27;s conclude our discussion of the complexities of asynchronous programming in C#. In this environment, developers employ asynchronous techniques, particularly in network programming, to efficiently handle operations without compromising application responsiveness.</p>
<p>In this context, various components, ranging from handling HTTP requests to managing file streams, are instrumental in overcoming the challenges posed by network latency and the potential for blocking user interfaces. Utilizing the <code v-pre>async</code> and <code v-pre>await</code> keywords, these operations are executed without interrupting the main application flow, thereby ensuring a seamless user experience despite the underlying complexities.</p>
<p>Throughout their journey in asynchronous programming, developers encounter numerous challenges, including the judicious use of <code v-pre>ConfigureAwait(false)</code> for resource optimization, applying concurrency control strategies, and implementing robust error handling to safeguard against unforeseen exceptions. The use of cancellation tokens plays a crucial role in providing a mechanism to abort operations gracefully, preventing resource leakage and ensuring clean operation termination. These strategies underscore the developers&#x27; ability to manage background tasks effectively, facilitating uninterrupted data exchange and maintaining the stability of the digital ecosystem.</p>

                                
                                <!-- Required only on API pages -->
                                <doc-toolbar-member-filter-no-results></doc-toolbar-member-filter-no-results>
                            </div>
                            <footer class="clear-both">
                                <div class="flex flex-wrap items-center justify-between mt-14">
                                    <a class="my-2.5 inline-flex items-center text-sm whitespace-nowrap text-blue-500 dark:text-blue-400 hover:text-blue-700 hover:underline" href="https://github.com/cwoodruff/book-network-programming-csharp/blob/main/Chapter04/chapter04.md" target="_blank" rel="noopener">
                                        <svg class="mr-1.5" xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="currentColor" overflow="visible"><path d="M20 12c-.55 0-1 .45-1 1v7c0 .55-.45 1-1 1H4c-.55 0-1-.45-1-1V6c0-.55.45-1 1-1h7c.55 0 1-.45 1-1s-.45-1-1-1H4C2.35 3 1 4.35 1 6v14c0 1.65 1.35 3 3 3h14c1.65 0 3-1.35 3-3v-7c0-.55-.45-1-1-1z" /><path d="M22.21 1.79c-1.18-1.18-3.24-1.18-4.41 0l-9.5 9.5c-.13.13-.22.29-.26.46l-1 4c-.08.34.01.7.26.95.18.2.44.3.7.3.08 0 .16-.01.24-.03l4-1c.18-.04.34-.13.46-.26l9.5-9.5c1.22-1.22 1.22-3.2.01-4.42zm-1.42 3l-9.3 9.3-2.11.53.53-2.11 9.3-9.3c.42-.42 1.16-.42 1.59 0 .43.43.43 1.15-.01 1.58z" /><path fill="none" d="M0 0h24v24H0z" /></svg>
                                        <span>Edit this page</span>
                                    </a>
                                </div>
                            
                                <nav class="flex mt-14">
                                    <div class="w-1/2">
                                        <a class="px-5 py-4 h-full flex items-center break-normal font-medium text-blue-500 dark:text-blue-400 border border-gray-300 hover:border-gray-400 dark:border-dark-650 dark:hover:border-dark-450 rounded-l-lg transition-colors duration-150 relative hover:z-5" href="../chapter03/">
                                            <svg xmlns="http://www.w3.org/2000/svg" class="mr-3" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" overflow="visible"><path d="M19 11H7.41l5.29-5.29a.996.996 0 10-1.41-1.41l-7 7a1 1 0 000 1.42l7 7a1.024 1.024 0 001.42-.01.996.996 0 000-1.41L7.41 13H19c.55 0 1-.45 1-1s-.45-1-1-1z" /><path fill="none" d="M0 0h24v24H0z" /></svg>
                                            <span>
                                                <span class="block text-xs font-normal text-gray-400 dark:text-dark-400">Previous</span>
                                                <span class="block mt-1">Chap 3 - Introduction to Socket Programming</span>
                                            </span>
                                        </a>
                                    </div>
                            
                                    <div class="w-1/2">
                                        <a class="px-5 py-4 -mx-px h-full flex items-center justify-end break-normal font-medium text-blue-500 dark:text-blue-400 border border-gray-300 hover:border-gray-400 dark:border-dark-650 dark:hover:border-dark-450 rounded-r-lg transition-colors duration-150 relative hover:z-5" href="../chapter05/">
                                            <span>
                                                <span class="block text-xs font-normal text-right text-gray-400 dark:text-dark-400">Next</span>
                                                <span class="block mt-1">Chap 5 - Multithreading in Network Applications</span>
                                            </span>
                                            <svg xmlns="http://www.w3.org/2000/svg" class="ml-3" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" overflow="visible"><path d="M19.92 12.38a1 1 0 00-.22-1.09l-7-7a.996.996 0 10-1.41 1.41l5.3 5.3H5c-.55 0-1 .45-1 1s.45 1 1 1h11.59l-5.29 5.29a.996.996 0 000 1.41c.19.2.44.3.7.3s.51-.1.71-.29l7-7c.09-.09.16-.21.21-.33z" /><path fill="none" d="M0 0h24v24H0z" /></svg>
                                        </a>
                                    </div>
                                </nav>
                            </footer>
                        </main>
                
                        <div class="border-t dark:border-dark-650 pt-6 mb-8">
                            <footer class="flex flex-wrap items-center justify-between">
                                <div>
                                    <ul class="flex flex-wrap items-center text-sm">
                                        <li>
                                            <a class="inline-flex items-center mr-4 py-2 text-sm whitespace-nowrap transition-colors duration-200 ease-linear text-blue-500 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-200 md:mb-0" href="../copyright/">
                                                <svg xmlns="http://www.w3.org/2000/svg" class="mb-px mr-1" width="18" height="18" viewBox="0 0 24 24" role="presentation">
                                                    <g fill="currentColor">
                                                        <path d="M10.97 8.265a1.45 1.45 0 0 0-.487.57.75.75 0 0 1-1.341-.67c.2-.402.513-.826.997-1.148C10.627 6.69 11.244 6.5 12 6.5c.658 0 1.369.195 1.934.619a2.45 2.45 0 0 1 1.004 2.006c0 1.033-.513 1.72-1.027 2.215-.19.183-.399.358-.579.508l-.147.123a4.329 4.329 0 0 0-.435.409v1.37a.75.75 0 1 1-1.5 0v-1.473c0-.237.067-.504.247-.736.22-.28.486-.517.718-.714l.183-.153.001-.001c.172-.143.324-.27.47-.412.368-.355.569-.676.569-1.136a.953.953 0 0 0-.404-.806C12.766 8.118 12.384 8 12 8c-.494 0-.814.121-1.03.265ZM13 17a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"/><path d="M12 1c6.075 0 11 4.925 11 11s-4.925 11-11 11S1 18.075 1 12 5.925 1 12 1ZM2.5 12a9.5 9.5 0 0 0 9.5 9.5 9.5 9.5 0 0 0 9.5-9.5A9.5 9.5 0 0 0 12 2.5 9.5 9.5 0 0 0 2.5 12Z"/>
                                                    </g>
                                                </svg>
                                                <span>Copyright</span>
                                            </a>
                                        </li>
                                        <li>
                                            <a class="inline-flex items-center mr-4 py-2 text-sm whitespace-nowrap transition-colors duration-200 ease-linear text-blue-500 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-200 md:mb-0" href="../license/">
                                                <svg xmlns="http://www.w3.org/2000/svg" class="mb-px mr-1" width="18" height="18" viewBox="0 0 24 24" role="presentation">
                                                    <g fill="currentColor">
                                                        <path d="M16.53 9.78a.75.75 0 0 0-1.06-1.06L11 13.19l-1.97-1.97a.75.75 0 0 0-1.06 1.06l2.5 2.5a.75.75 0 0 0 1.06 0l5-5Z"/><path d="m12.54.637 8.25 2.675A1.75 1.75 0 0 1 22 4.976V10c0 6.19-3.771 10.704-9.401 12.83a1.704 1.704 0 0 1-1.198 0C5.77 20.705 2 16.19 2 10V4.976c0-.758.489-1.43 1.21-1.664L11.46.637a1.748 1.748 0 0 1 1.08 0Zm-.617 1.426-8.25 2.676a.249.249 0 0 0-.173.237V10c0 5.46 3.28 9.483 8.43 11.426a.199.199 0 0 0 .14 0C17.22 19.483 20.5 15.461 20.5 10V4.976a.25.25 0 0 0-.173-.237l-8.25-2.676a.253.253 0 0 0-.154 0Z"/>
                                                    </g>
                                                </svg>
                                                <span>License</span>
                                            </a>
                                        </li>
                                    </ul>
                                </div>
                                <div class="docs-copyright py-2 text-gray-500 dark:text-dark-350 text-sm leading-relaxed"><p>© Copyright 2024. All rights reserved Chris Woodruff.</p></div>
                            </footer>
                        </div>
                    </div>
                
                    <!-- Rendered if sidebar right is enabled -->
                    <!-- Sidebar right skeleton-->
                    <div v-cloak class="fixed top-0 bottom-0 right-0 translate-x-full bg-white border-gray-200 lg:sticky lg:border-l lg:shrink-0 lg:pt-6 lg:transform-none sm:w-1/2 lg:w-64 lg:z-0 md:w-104 sidebar-right skeleton dark:bg-dark-850 dark:border-dark-650">
                        <div class="pl-5">
                            <div class="w-32 h-3 mb-4 bg-gray-200 dark:bg-dark-600 rounded-full loading"></div>
                            <div class="w-48 h-3 mb-4 bg-gray-200 dark:bg-dark-600 rounded-full loading"></div>
                            <div class="w-40 h-3 mb-4 bg-gray-200 dark:bg-dark-600 rounded-full loading"></div>
                        </div>
                    </div>
                
                    <!-- User should be able to hide sidebar right -->
                    <doc-sidebar-right v-cloak></doc-sidebar-right>
                </div>

            </div>
        </div>
    
        <doc-search-mobile></doc-search-mobile>
        <doc-back-to-top></doc-back-to-top>
    </div>


    <div id="docs-overlay-target"></div>

    <script data-cfasync="false">window.__DOCS__ = { "title": "Chap 4 - Asynchronous Programming with Async/Await", level: 1, icon: "file", hasPrism: true, hasMermaid: false, hasMath: false, tocDepth: 23 }</script>
</body>
</html>
